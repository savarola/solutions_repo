{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 :Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion offers a fascinating opportunity to explore physics principles, where equations governing the motion of projectiles describe not just the motion of objects like soccer balls or rockets but can also be extended to study more complex systems in engineering and astrophysics. The basic setup involves the analysis of how the range (the horizontal distance traveled) of a projectile depends on the angle of projection. 1. Theoretical Foundation: Derivation of the Governing Equations Projectile motion is typically modeled in two dimensions (horizontal and vertical) under the influence of gravity. We start by analyzing the motion in both directions independently. Horizontal motion (x-direction): The horizontal velocity is constant, as there are no forces acting horizontally (assuming no air resistance). \\[ \\frac{d^2 x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) \\] Where: - \\(v_0\\) is the initial velocity. - \\(\\theta\\) is the launch angle. The solution to this differential equation is: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (y-direction): The vertical motion is influenced by gravity, which causes a downward acceleration. \\[ \\frac{d^2 y}{dt^2} = -g \\] Where \\(g\\) is the acceleration due to gravity (approximately \\(9.8 \\, \\text{m/s}^2\\) on Earth). The solution to this differential equation is: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] This equation describes the height of the projectile as a function of time. Time of Flight and Range To find the time of flight, we set \\(y(t) = 0\\) because the projectile will return to the ground when it reaches the same vertical position (height = 0). Solving for \\(t\\) , we get: \\[ 0 = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] This simplifies to: \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\(R\\) of the projectile is the horizontal distance it travels when it reaches the ground, which occurs at time \\(t\\) . From the horizontal motion equation, we have: \\[ R = x(t) = v_0 \\cos(\\theta) \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying the expression: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the equation for the range of a projectile. 2. Analysis of the Range: Range as a Function of the Launch Angle From the derived equation: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] We observe that the range \\(R\\) depends on: - The initial velocity \\(v_0\\) , - The launch angle \\(\\theta\\) , - The gravitational acceleration \\(g\\) . Since \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , this means the optimal launch angle for maximum range is: \\[ \\theta = 45^\\circ \\] Thus, the range is maximized at a \\(45^\\circ\\) launch angle. As \\(\\theta\\) deviates from \\(45^\\circ\\) , the range decreases due to the behavior of the sine function. import matplotlib.pyplot as plt import numpy as np # Acceleration due to gravity g = 9.81 # Function to compute trajectory def trajectory(v0, angle_deg): angle_rad = np.radians(angle_deg) flight_time = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, flight_time, num=200) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Create subplots fig, axs = plt.subplots(2, 1, figsize=(10, 12)) # (a) Different speeds at 45 degrees axs[0].set_title('(a) Different Initial Speeds at 45\u00b0') for v0, color in zip([30, 40, 50], ['orange', 'orangered', 'crimson']): x, y = trajectory(v0, 45) axs[0].plot(x, y, label=f'{v0} m/s', color=color) axs[0].set_xlabel('x (m)') axs[0].set_ylabel('y (m)') axs[0].legend() axs[0].grid(True) # (b) Same speed (50 m/s) with different angles axs[1].set_title('(b) Same Initial Speed (50 m/s) at Different Angles') for angle, color in zip([15, 45, 75], ['gold', 'darkorange', 'crimson']): x, y = trajectory(50, angle) axs[1].plot(x, y, label=f'{angle}\u00b0', color=color) axs[1].set_xlabel('x (m)') axs[1].set_ylabel('y (m)') axs[1].legend() axs[1].grid(True) plt.tight_layout() plt.show() Visit My Collab Influence of Initial Velocity and Gravitational Acceleration Initial Velocity \\(v_0\\) : The range increases with the square of the initial velocity. This means that increasing the initial speed at which the projectile is launched increases the range, but the relationship is quadratic. Gravitational Acceleration \\(g\\) : The range decreases as gravity increases. If gravity is stronger (like on a larger planet), the range will be smaller for the same initial velocity and launch angle. 3. Practical Applications: This model can be applied to many real-world scenarios, such as: - Sports : In games like soccer, basketball, and golf, the angle at which a ball is kicked, thrown, or hit can dramatically affect the distance traveled. - Engineering : This model can be used to calculate the range of artillery shells, missiles, or drones, considering varying initial velocities and launch angles. - Astrophysics : The principles of projectile motion under gravity are useful in studying the trajectories of satellites, space probes, and other celestial objects. 4. Implementation: To simulate the projectile motion and visualize the range as a function of the launch angle, you can write a Python script using libraries such as NumPy and Matplotlib. Here\u2019s an implementation of the simulation: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.8 # acceleration due to gravity (m/s^2) v0 = 20 # initial velocity (m/s) # Define a function to calculate the range for a given angle def range_of_projectile(v0, theta_deg, g): theta = np.radians(theta_deg) # convert angle to radians return (v0**2 * np.sin(2*theta)) / g # Angle range from 0 to 90 degrees angles = np.linspace(0, 90, 500) # Calculate the range for each angle ranges = range_of_projectile(v0, angles, g) # Plot the results plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=\"Range vs Angle\") plt.title(\"Projectile Range as a Function of Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.show() Output Interpretation This graph will display the projectile range as a function of the launch angle, showing that the range is maximized at a $45^\\circ$ angle and decreases as the angle deviates from this optimal value. Visit My Collab 5. Limitations and Suggestions for Improvements: The current model assumes: No air resistance, which isn't realistic for most real-world projectiles. Flat ground, neglecting any effects of terrain variation. Constant gravitational acceleration, which isn't accurate for higher altitudes or other celestial bodies. To improve the model, you could: Incorporate air resistance using drag equations to model the deceleration of the projectile. Account for varying terrain by modifying the initial and final conditions of the projectile\u2019s path. Consider varying gravity for different planetary conditions (e.g., Mars, Moon). Conclusion Through this task, we explored the fundamental principles of projectile motion and derived the governing equations. By analyzing how the range depends on the launch angle, initial velocity, and gravity, we gained insight into both the physics and practical applications of projectile motion. The implementation of a simulation further enhances the understanding by visualizing the relationships and behaviors. Finally, by reflecting on the limitations of the idealized model, we identified possible improvements for more accurate real-world modeling.","title":"Problem 1 :Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1 :Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion offers a fascinating opportunity to explore physics principles, where equations governing the motion of projectiles describe not just the motion of objects like soccer balls or rockets but can also be extended to study more complex systems in engineering and astrophysics. The basic setup involves the analysis of how the range (the horizontal distance traveled) of a projectile depends on the angle of projection.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-the-governing-equations","text":"Projectile motion is typically modeled in two dimensions (horizontal and vertical) under the influence of gravity. We start by analyzing the motion in both directions independently.","title":"Derivation of the Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-x-direction","text":"The horizontal velocity is constant, as there are no forces acting horizontally (assuming no air resistance). \\[ \\frac{d^2 x}{dt^2} = 0 \\quad \\Rightarrow \\quad \\frac{dx}{dt} = v_0 \\cos(\\theta) \\] Where: - \\(v_0\\) is the initial velocity. - \\(\\theta\\) is the launch angle. The solution to this differential equation is: \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\]","title":"Horizontal motion (x-direction):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-y-direction","text":"The vertical motion is influenced by gravity, which causes a downward acceleration. \\[ \\frac{d^2 y}{dt^2} = -g \\] Where \\(g\\) is the acceleration due to gravity (approximately \\(9.8 \\, \\text{m/s}^2\\) on Earth). The solution to this differential equation is: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] This equation describes the height of the projectile as a function of time.","title":"Vertical motion (y-direction):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight-and-range","text":"To find the time of flight, we set \\(y(t) = 0\\) because the projectile will return to the ground when it reaches the same vertical position (height = 0). Solving for \\(t\\) , we get: \\[ 0 = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] This simplifies to: \\[ t = \\frac{2 v_0 \\sin(\\theta)}{g} \\] The range \\(R\\) of the projectile is the horizontal distance it travels when it reaches the ground, which occurs at time \\(t\\) . From the horizontal motion equation, we have: \\[ R = x(t) = v_0 \\cos(\\theta) \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying the expression: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This is the equation for the range of a projectile.","title":"Time of Flight and Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-as-a-function-of-the-launch-angle","text":"From the derived equation: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] We observe that the range \\(R\\) depends on: - The initial velocity \\(v_0\\) , - The launch angle \\(\\theta\\) , - The gravitational acceleration \\(g\\) . Since \\(\\sin(2\\theta)\\) reaches its maximum value of 1 when \\(2\\theta = 90^\\circ\\) , this means the optimal launch angle for maximum range is: \\[ \\theta = 45^\\circ \\] Thus, the range is maximized at a \\(45^\\circ\\) launch angle. As \\(\\theta\\) deviates from \\(45^\\circ\\) , the range decreases due to the behavior of the sine function. import matplotlib.pyplot as plt import numpy as np # Acceleration due to gravity g = 9.81 # Function to compute trajectory def trajectory(v0, angle_deg): angle_rad = np.radians(angle_deg) flight_time = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, flight_time, num=200) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Create subplots fig, axs = plt.subplots(2, 1, figsize=(10, 12)) # (a) Different speeds at 45 degrees axs[0].set_title('(a) Different Initial Speeds at 45\u00b0') for v0, color in zip([30, 40, 50], ['orange', 'orangered', 'crimson']): x, y = trajectory(v0, 45) axs[0].plot(x, y, label=f'{v0} m/s', color=color) axs[0].set_xlabel('x (m)') axs[0].set_ylabel('y (m)') axs[0].legend() axs[0].grid(True) # (b) Same speed (50 m/s) with different angles axs[1].set_title('(b) Same Initial Speed (50 m/s) at Different Angles') for angle, color in zip([15, 45, 75], ['gold', 'darkorange', 'crimson']): x, y = trajectory(50, angle) axs[1].plot(x, y, label=f'{angle}\u00b0', color=color) axs[1].set_xlabel('x (m)') axs[1].set_ylabel('y (m)') axs[1].legend() axs[1].grid(True) plt.tight_layout() plt.show() Visit My Collab","title":"Range as a Function of the Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-initial-velocity-and-gravitational-acceleration","text":"Initial Velocity \\(v_0\\) : The range increases with the square of the initial velocity. This means that increasing the initial speed at which the projectile is launched increases the range, but the relationship is quadratic. Gravitational Acceleration \\(g\\) : The range decreases as gravity increases. If gravity is stronger (like on a larger planet), the range will be smaller for the same initial velocity and launch angle.","title":"Influence of Initial Velocity and Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model can be applied to many real-world scenarios, such as: - Sports : In games like soccer, basketball, and golf, the angle at which a ball is kicked, thrown, or hit can dramatically affect the distance traveled. - Engineering : This model can be used to calculate the range of artillery shells, missiles, or drones, considering varying initial velocities and launch angles. - Astrophysics : The principles of projectile motion under gravity are useful in studying the trajectories of satellites, space probes, and other celestial objects.","title":"3. Practical Applications:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"To simulate the projectile motion and visualize the range as a function of the launch angle, you can write a Python script using libraries such as NumPy and Matplotlib. Here\u2019s an implementation of the simulation: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.8 # acceleration due to gravity (m/s^2) v0 = 20 # initial velocity (m/s) # Define a function to calculate the range for a given angle def range_of_projectile(v0, theta_deg, g): theta = np.radians(theta_deg) # convert angle to radians return (v0**2 * np.sin(2*theta)) / g # Angle range from 0 to 90 degrees angles = np.linspace(0, 90, 500) # Calculate the range for each angle ranges = range_of_projectile(v0, angles, g) # Plot the results plt.figure(figsize=(8, 6)) plt.plot(angles, ranges, label=\"Range vs Angle\") plt.title(\"Projectile Range as a Function of Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.show() Output Interpretation This graph will display the projectile range as a function of the launch angle, showing that the range is maximized at a $45^\\circ$ angle and decreases as the angle deviates from this optimal value. Visit My Collab","title":"4. Implementation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-limitations-and-suggestions-for-improvements","text":"The current model assumes: No air resistance, which isn't realistic for most real-world projectiles. Flat ground, neglecting any effects of terrain variation. Constant gravitational acceleration, which isn't accurate for higher altitudes or other celestial bodies. To improve the model, you could: Incorporate air resistance using drag equations to model the deceleration of the projectile. Account for varying terrain by modifying the initial and final conditions of the projectile\u2019s path. Consider varying gravity for different planetary conditions (e.g., Mars, Moon). Conclusion Through this task, we explored the fundamental principles of projectile motion and derived the governing equations. By analyzing how the range depends on the launch angle, initial velocity, and gravity, we gained insight into both the physics and practical applications of projectile motion. The implementation of a simulation further enhances the understanding by visualizing the relationships and behaviors. Finally, by reflecting on the limitations of the idealized model, we identified possible improvements for more accurate real-world modeling.","title":"5. Limitations and Suggestions for Improvements:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 :Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum represents a fascinating example of nonlinear dynamics. When both damping and external forcing are introduced, the pendulum displays a wide array of behaviors\u2014from simple periodic motion to resonance and chaos. These dynamics mirror those found in systems such as climate models, mechanical resonators, and electrical circuits. 1. Theoretical Foundation The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: \\(\\theta\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(g\\) is the acceleration due to gravity, \\(L\\) is the length of the pendulum, \\(A\\) is the amplitude of the driving force, \\(\\omega\\) is the driving frequency. Small-Angle Approximation For small \\(\\theta\\) , we can use the approximation \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear non-homogeneous differential equation with a general solution composed of a transient (homogeneous) and a steady-state (particular) solution. Resonance Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the system can exhibit large amplitude oscillations, especially when damping is low ( \\(b \\ll 1\\) ). The amplitude of steady-state oscillations is maximized near resonance. 2. Analysis of Dynamics To study the system numerically, we convert the second-order equation into two first-order ODEs: Let: - \\(\\theta_1 = \\theta\\) - \\(\\theta_2 = \\frac{d\\theta}{dt}\\) Then: \\[ \\frac{d\\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d\\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin\\theta_1 + A \\cos(\\omega t) \\] Parameter Effects Damping ( \\(b\\) ) : Reduces amplitude and can suppress chaotic behavior. Driving Amplitude ( \\(A\\) ) : Higher values can induce chaotic behavior. Driving Frequency ( \\(\\omega\\) ) : Determines resonance conditions and the potential for complex behavior. Transition to Chaos As parameters (e.g., \\(A\\) , \\(\\omega\\) ) are varied, the system transitions from periodic to quasiperiodic, and eventually to chaotic motion. Indicators include: Sensitivity to initial conditions, Strange attractors in phase space, Irregular time series. 3. Practical Applications Energy Harvesting Devices : Use resonant mechanical systems to convert vibrational energy. Suspension Bridges : Modeled using driven oscillators under periodic loading. Oscillating Electrical Circuits : Analogous to forced damped pendulums (e.g., RLC circuits). Biomechanics : Human gait and limb motion can be approximated by driven pendulums. 4. Implementation Python Simulation Outline import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # \u0423\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u044f\u0442\u043d\u0438\u043a\u0430: d\u00b2\u03b8/dt\u00b2 + b*d\u03b8/dt + sin(\u03b8) = A*cos(\u03c9*t) def pendulum(t, y, b, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f: \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u03b8(t) \u0438 (\u03b8, \u03c9) def plot_pendulum(t, sol, title, color): theta = sol[0] omega = sol[1] fig, ax = plt.subplots(1, 2, figsize=(14, 4)) fig.suptitle(title, fontsize=16) ax[0].plot(t, theta, color=color) ax[0].set_title(\"Time Series\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Angle (rad)\") ax[0].grid(True) ax[1].plot(theta, omega, color=color) ax[1].set_title(\"Phase Portrait\") ax[1].set_xlabel(\"\u03b8 (rad)\") ax[1].set_ylabel(\"\u03c9 (rad/s)\") ax[1].grid(True) plt.tight_layout() plt.subplots_adjust(top=0.85) # \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043d\u0435 \u043d\u0430\u043b\u0435\u0437\u0430\u043b plt.show() # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f t_span = (0, 30) t_eval = np.linspace(*t_span, 2000) initial_state = [0.1, 0.0] # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u0443\u0433\u043e\u043b \u0438 \u0443\u0433\u043b\u043e\u0432\u0430\u044f \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c # ===== 1. Simple Pendulum ===== sol1 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 0.0, 0.0)) plot_pendulum(sol1.t, sol1.y, \"1) Simple Pendulum (b=0, A=0)\", \"crimson\") # ===== 2. Damped Pendulum ===== sol2 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 0.0, 0.0)) plot_pendulum(sol2.t, sol2.y, \"2) Damped Pendulum (b=0.5, A=0)\", \"darkblue\") # ===== 3. Forced Pendulum ===== sol3 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 1.0, 2.0)) plot_pendulum(sol3.t, sol3.y, \"3) Forced Pendulum (b=0, A=1.0, \u03c9=2.0)\", \"teal\") # ===== 4. Forced Damped Pendulum ===== sol4 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.2, 1.2, 2.0)) plot_pendulum(sol4.t, sol4.y, \"4) Forced Damped Pendulum (b=0.2, A=1.2, \u03c9=2.0)\", \"orange\") # ===== 5. Chaotic / Resonant Pendulum ===== sol5 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 1.5, 2/3)) plot_pendulum(sol5.t, sol5.y, \"5) Chaotic / Resonant Pendulum (b=0.5, A=1.5, \u03c9=2/3)\", \"firebrick\") Visit My Collab","title":"Problem 2 :Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 2 :Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum represents a fascinating example of nonlinear dynamics. When both damping and external forcing are introduced, the pendulum displays a wide array of behaviors\u2014from simple periodic motion to resonance and chaos. These dynamics mirror those found in systems such as climate models, mechanical resonators, and electrical circuits.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = A \\cos(\\omega t) \\] Where: \\(\\theta\\) is the angular displacement, \\(b\\) is the damping coefficient, \\(g\\) is the acceleration due to gravity, \\(L\\) is the length of the pendulum, \\(A\\) is the amplitude of the driving force, \\(\\omega\\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small \\(\\theta\\) , we can use the approximation \\(\\sin\\theta \\approx \\theta\\) , reducing the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear non-homogeneous differential equation with a general solution composed of a transient (homogeneous) and a steady-state (particular) solution.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the system can exhibit large amplitude oscillations, especially when damping is low ( \\(b \\ll 1\\) ). The amplitude of steady-state oscillations is maximized near resonance.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"To study the system numerically, we convert the second-order equation into two first-order ODEs: Let: - \\(\\theta_1 = \\theta\\) - \\(\\theta_2 = \\frac{d\\theta}{dt}\\) Then: \\[ \\frac{d\\theta_1}{dt} = \\theta_2 \\] \\[ \\frac{d\\theta_2}{dt} = -b \\theta_2 - \\frac{g}{L} \\sin\\theta_1 + A \\cos(\\omega t) \\]","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameter-effects","text":"Damping ( \\(b\\) ) : Reduces amplitude and can suppress chaotic behavior. Driving Amplitude ( \\(A\\) ) : Higher values can induce chaotic behavior. Driving Frequency ( \\(\\omega\\) ) : Determines resonance conditions and the potential for complex behavior.","title":"Parameter Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"As parameters (e.g., \\(A\\) , \\(\\omega\\) ) are varied, the system transitions from periodic to quasiperiodic, and eventually to chaotic motion. Indicators include: Sensitivity to initial conditions, Strange attractors in phase space, Irregular time series.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting Devices : Use resonant mechanical systems to convert vibrational energy. Suspension Bridges : Modeled using driven oscillators under periodic loading. Oscillating Electrical Circuits : Analogous to forced damped pendulums (e.g., RLC circuits). Biomechanics : Human gait and limb motion can be approximated by driven pendulums.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-simulation-outline","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # \u0423\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u044f\u0442\u043d\u0438\u043a\u0430: d\u00b2\u03b8/dt\u00b2 + b*d\u03b8/dt + sin(\u03b8) = A*cos(\u03c9*t) def pendulum(t, y, b, A, omega): theta, omega_ = y dtheta_dt = omega_ domega_dt = -b * omega_ - np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # \u0412\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f: \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u03b8(t) \u0438 (\u03b8, \u03c9) def plot_pendulum(t, sol, title, color): theta = sol[0] omega = sol[1] fig, ax = plt.subplots(1, 2, figsize=(14, 4)) fig.suptitle(title, fontsize=16) ax[0].plot(t, theta, color=color) ax[0].set_title(\"Time Series\") ax[0].set_xlabel(\"Time (s)\") ax[0].set_ylabel(\"Angle (rad)\") ax[0].grid(True) ax[1].plot(theta, omega, color=color) ax[1].set_title(\"Phase Portrait\") ax[1].set_xlabel(\"\u03b8 (rad)\") ax[1].set_ylabel(\"\u03c9 (rad/s)\") ax[1].grid(True) plt.tight_layout() plt.subplots_adjust(top=0.85) # \u0447\u0442\u043e\u0431\u044b \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043d\u0435 \u043d\u0430\u043b\u0435\u0437\u0430\u043b plt.show() # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f t_span = (0, 30) t_eval = np.linspace(*t_span, 2000) initial_state = [0.1, 0.0] # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u0443\u0433\u043e\u043b \u0438 \u0443\u0433\u043b\u043e\u0432\u0430\u044f \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c # ===== 1. Simple Pendulum ===== sol1 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 0.0, 0.0)) plot_pendulum(sol1.t, sol1.y, \"1) Simple Pendulum (b=0, A=0)\", \"crimson\") # ===== 2. Damped Pendulum ===== sol2 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 0.0, 0.0)) plot_pendulum(sol2.t, sol2.y, \"2) Damped Pendulum (b=0.5, A=0)\", \"darkblue\") # ===== 3. Forced Pendulum ===== sol3 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.0, 1.0, 2.0)) plot_pendulum(sol3.t, sol3.y, \"3) Forced Pendulum (b=0, A=1.0, \u03c9=2.0)\", \"teal\") # ===== 4. Forced Damped Pendulum ===== sol4 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.2, 1.2, 2.0)) plot_pendulum(sol4.t, sol4.y, \"4) Forced Damped Pendulum (b=0.2, A=1.2, \u03c9=2.0)\", \"orange\") # ===== 5. Chaotic / Resonant Pendulum ===== sol5 = solve_ivp(pendulum, t_span, initial_state, t_eval=t_eval, args=(0.5, 1.5, 2/3)) plot_pendulum(sol5.t, sol5.y, \"5) Chaotic / Resonant Pendulum (b=0.5, A=1.5, \u03c9=2/3)\", \"firebrick\") Visit My Collab","title":"Python Simulation Outline"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1: Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This law reveals a fundamental connection between time and space in planetary systems and provides the theoretical foundation for understanding orbital motion in gravitational systems. 1. Derivation of Kepler\u2019s Third Law for Circular Orbits Consider an object of mass \\(m\\) orbiting a much more massive body (e.g., a planet around the Sun) in a circular orbit of radius \\(r\\) . The gravitational force provides the necessary centripetal force: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\Rightarrow \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body, \\(v\\) is the orbital velocity, \\(r\\) is the orbital radius. Canceling \\(m\\) and solving for \\(v\\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is: \\[ T = \\frac{2 \\pi r}{v} \\Rightarrow T^2 = \\left(\\frac{2 \\pi r}{v}\\right)^2 = \\frac{4 \\pi^2 r^2}{v^2} \\] Substitute \\(v^2 = \\frac{G M}{r}\\) : \\[ T^2 = \\frac{4 \\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4 \\pi^2 r^3}{G M} \\] Therefore, \\[ T^2 \\propto r^3 \\] This is Kepler\u2019s Third Law for circular orbits. 2. Implications for Astronomy Determining Planetary Masses : If T and r of a satellite are known, we can solve for the mass M of the central body: M = (4 * \u03c0\u00b2 * r\u00b3) / (G * T\u00b2) Calculating Orbital Distances : Given the period T (e.g., from observations), we can calculate the average orbital radius r. Satellite Engineering : The altitude and speed of satellites in Earth orbit can be precisely determined using this law. 3. \ud83c\udf1e Mass of the Sun via Kepler\u2019s Third Law \ud83d\udcd8 Theoretical Background Kepler\u2019s Third Law states that the square of the orbital period of a planet is proportional to the cube of the semi-major axis of its orbit: \\[ T^2 \\propto a^3 \\] Using Newton\u2019s formulation of gravitation, we write: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Where: \\(T\\) : Orbital period in seconds \\(a\\) : Semi-major axis in meters \\(G\\) : Universal gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) ) \\(M\\) : Mass of the central object (the Sun in this case) Solving for \\(M\\) : \\[ M = \\frac{4\\pi^2 a^3}{G T^2} \\] \ud83c\udf0d Estimating the Mass of the Sun Using Earth\u2019s Orbit Using Earth's orbit, where: \\(T = 365.25 \\, \\text{days} = 365.25 \\times 24 \\times 3600 \\approx 31,557,600 \\, \\text{s}\\) \\(a = 1 \\, \\text{AU} = 1.496 \\times 10^{11} \\, \\text{m}\\) Substitute these values into the formula: \\[ M = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11})(31,557,600)^2} \\] Which yields: \\[ M \\approx 1.989 \\times 10^{30} \\, \\text{kg} \\] \ud83d\udd0d Observations and Notes The calculation above estimates the mass of the Sun using only Earth\u2019s orbital characteristics. The result aligns closely with the accepted value of the solar mass. Kepler\u2019s Third Law, when combined with Newtonian mechanics, allows us to infer properties of celestial bodies without directly observing them. 4. Real-World Examples a) The Moon Orbiting Earth \\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) s \\(r \\approx 3.84 \\times 10^8\\) m Plug into: \\[ M_{\\text{Earth}} = \\frac{4 \\pi^2 r^3}{G T^2} \\] We obtain: \\(M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\) kg b) Planets in the Solar System The table below shows the empirical validation of \\(T^2 \\propto r^3\\) using Solar System data: Planet \\(r\\) (AU) \\(T\\) (yr) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Saturn 9.58 29.46 867.8 878.4 The close match confirms the law. import numpy as np import matplotlib.pyplot as plt # Planet data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T_years = [0.2408, 0.6152, 1.000, 1.8808] # Orbital periods in Earth years a_AU = [0.387, 0.723, 1.000, 1.524] # Semi-major axes in astronomical units (AU) # Calculate T^2 and a^3 T_squared = [T**2 for T in T_years] a_cubed = [a**3 for a in a_AU] # Plotting the graph plt.figure(figsize=(8, 6)) plt.plot(a_cubed, T_squared, 'o-', color='dodgerblue', label='Planets') # Annotate each planet for i, name in enumerate(planets): plt.text(a_cubed[i] * 1.02, T_squared[i] * 0.98, name) # Add labels, title, grid, and reference line plt.title(\"Kepler's 3rd Law: $T^2$ vs $a^3$\", fontsize=14) plt.xlabel(\"$a^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (Years\u00b2)\", fontsize=12) plt.grid(True) # Expected reference line with slope = 1 (perfect linear relation) plt.axline((0, 0), slope=1, color='gray', linestyle='--', label='Expected line (slope = 1)') plt.legend() plt.tight_layout() plt.show() Visit My Collab 5. Extension to Elliptical Orbits Kepler's Third Law also applies to elliptical orbits , not just circular ones. In this generalized case, the orbital radius \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse. \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Where: \\(T\\) is the orbital period, \\(a\\) is the semi-major axis of the ellipse, \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body. Implications This form of Kepler\u2019s law is valid for all bound two-body systems , including: Planets with slightly elliptical orbits, Comets with highly eccentric orbits, Binary star systems, Exoplanets around distant stars. Astronomers use it to: Calculate stellar masses in binary systems, Estimate orbital distances from observed periods, Model elliptical orbits in simulations and ephemerides. Visualization Suggestion To visualize an elliptical orbit and highlight the semi-major axis: Plot an ellipse using the equation: (x\u00b2 / a\u00b2) + (y\u00b2 / b\u00b2) = 1 where: - a is the semi-major axis, - b is the semi-minor axis, - The central mass is located at one of the foci. Final Remark Kepler\u2019s Third Law for elliptical orbits can also be written as: \\[ \\frac{T^2}{a^3} = \\text{constant} \\] This constant depends only on the gravitational parameter \\(GM\\) of the central body and is independent of orbital eccentricity for bound systems.","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This law reveals a fundamental connection between time and space in planetary systems and provides the theoretical foundation for understanding orbital motion in gravitational systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-keplers-third-law-for-circular-orbits","text":"Consider an object of mass \\(m\\) orbiting a much more massive body (e.g., a planet around the Sun) in a circular orbit of radius \\(r\\) . The gravitational force provides the necessary centripetal force: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\Rightarrow \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body, \\(v\\) is the orbital velocity, \\(r\\) is the orbital radius. Canceling \\(m\\) and solving for \\(v\\) : \\[ v^2 = \\frac{G M}{r} \\] The orbital period \\(T\\) is: \\[ T = \\frac{2 \\pi r}{v} \\Rightarrow T^2 = \\left(\\frac{2 \\pi r}{v}\\right)^2 = \\frac{4 \\pi^2 r^2}{v^2} \\] Substitute \\(v^2 = \\frac{G M}{r}\\) : \\[ T^2 = \\frac{4 \\pi^2 r^2}{\\frac{G M}{r}} = \\frac{4 \\pi^2 r^3}{G M} \\] Therefore, \\[ T^2 \\propto r^3 \\] This is Kepler\u2019s Third Law for circular orbits.","title":"1. Derivation of Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Determining Planetary Masses : If T and r of a satellite are known, we can solve for the mass M of the central body: M = (4 * \u03c0\u00b2 * r\u00b3) / (G * T\u00b2) Calculating Orbital Distances : Given the period T (e.g., from observations), we can calculate the average orbital radius r. Satellite Engineering : The altitude and speed of satellites in Earth orbit can be precisely determined using this law.","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-mass-of-the-sun-via-keplers-third-law","text":"","title":"3. \ud83c\udf1e Mass of the Sun via Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-background","text":"Kepler\u2019s Third Law states that the square of the orbital period of a planet is proportional to the cube of the semi-major axis of its orbit: \\[ T^2 \\propto a^3 \\] Using Newton\u2019s formulation of gravitation, we write: \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Where: \\(T\\) : Orbital period in seconds \\(a\\) : Semi-major axis in meters \\(G\\) : Universal gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}\\) ) \\(M\\) : Mass of the central object (the Sun in this case) Solving for \\(M\\) : \\[ M = \\frac{4\\pi^2 a^3}{G T^2} \\]","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#estimating-the-mass-of-the-sun-using-earths-orbit","text":"Using Earth's orbit, where: \\(T = 365.25 \\, \\text{days} = 365.25 \\times 24 \\times 3600 \\approx 31,557,600 \\, \\text{s}\\) \\(a = 1 \\, \\text{AU} = 1.496 \\times 10^{11} \\, \\text{m}\\) Substitute these values into the formula: \\[ M = \\frac{4\\pi^2 (1.496 \\times 10^{11})^3}{(6.67430 \\times 10^{-11})(31,557,600)^2} \\] Which yields: \\[ M \\approx 1.989 \\times 10^{30} \\, \\text{kg} \\]","title":"\ud83c\udf0d Estimating the Mass of the Sun Using Earth\u2019s Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#observations-and-notes","text":"The calculation above estimates the mass of the Sun using only Earth\u2019s orbital characteristics. The result aligns closely with the accepted value of the solar mass. Kepler\u2019s Third Law, when combined with Newtonian mechanics, allows us to infer properties of celestial bodies without directly observing them.","title":"\ud83d\udd0d Observations and Notes"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-real-world-examples","text":"","title":"4. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#a-the-moon-orbiting-earth","text":"\\(T \\approx 27.3\\) days \\(= 2.36 \\times 10^6\\) s \\(r \\approx 3.84 \\times 10^8\\) m Plug into: \\[ M_{\\text{Earth}} = \\frac{4 \\pi^2 r^3}{G T^2} \\] We obtain: \\(M_{\\text{Earth}} \\approx 5.97 \\times 10^{24}\\) kg","title":"a) The Moon Orbiting Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#b-planets-in-the-solar-system","text":"The table below shows the empirical validation of \\(T^2 \\propto r^3\\) using Solar System data: Planet \\(r\\) (AU) \\(T\\) (yr) \\(T^2\\) \\(r^3\\) Earth 1.00 1.00 1.00 1.00 Mars 1.52 1.88 3.53 3.51 Jupiter 5.20 11.86 140.7 140.6 Saturn 9.58 29.46 867.8 878.4 The close match confirms the law. import numpy as np import matplotlib.pyplot as plt # Planet data planets = ['Mercury', 'Venus', 'Earth', 'Mars'] T_years = [0.2408, 0.6152, 1.000, 1.8808] # Orbital periods in Earth years a_AU = [0.387, 0.723, 1.000, 1.524] # Semi-major axes in astronomical units (AU) # Calculate T^2 and a^3 T_squared = [T**2 for T in T_years] a_cubed = [a**3 for a in a_AU] # Plotting the graph plt.figure(figsize=(8, 6)) plt.plot(a_cubed, T_squared, 'o-', color='dodgerblue', label='Planets') # Annotate each planet for i, name in enumerate(planets): plt.text(a_cubed[i] * 1.02, T_squared[i] * 0.98, name) # Add labels, title, grid, and reference line plt.title(\"Kepler's 3rd Law: $T^2$ vs $a^3$\", fontsize=14) plt.xlabel(\"$a^3$ (AU\u00b3)\", fontsize=12) plt.ylabel(\"$T^2$ (Years\u00b2)\", fontsize=12) plt.grid(True) # Expected reference line with slope = 1 (perfect linear relation) plt.axline((0, 0), slope=1, color='gray', linestyle='--', label='Expected line (slope = 1)') plt.legend() plt.tight_layout() plt.show()","title":"b) Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visit-my-collab","text":"","title":"Visit My Collab"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-to-elliptical-orbits","text":"Kepler's Third Law also applies to elliptical orbits , not just circular ones. In this generalized case, the orbital radius \\(r\\) is replaced by the semi-major axis \\(a\\) of the ellipse. \\[ T^2 = \\frac{4\\pi^2 a^3}{G M} \\] Where: \\(T\\) is the orbital period, \\(a\\) is the semi-major axis of the ellipse, \\(G\\) is the gravitational constant, \\(M\\) is the mass of the central body.","title":"5. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications","text":"This form of Kepler\u2019s law is valid for all bound two-body systems , including: Planets with slightly elliptical orbits, Comets with highly eccentric orbits, Binary star systems, Exoplanets around distant stars. Astronomers use it to: Calculate stellar masses in binary systems, Estimate orbital distances from observed periods, Model elliptical orbits in simulations and ephemerides.","title":"Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#visualization-suggestion","text":"To visualize an elliptical orbit and highlight the semi-major axis: Plot an ellipse using the equation: (x\u00b2 / a\u00b2) + (y\u00b2 / b\u00b2) = 1 where: - a is the semi-major axis, - b is the semi-minor axis, - The central mass is located at one of the foci.","title":"Visualization Suggestion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-remark","text":"Kepler\u2019s Third Law for elliptical orbits can also be written as: \\[ \\frac{T^2}{a^3} = \\text{constant} \\] This constant depends only on the gravitational parameter \\(GM\\) of the central body and is independent of orbital eccentricity for bound systems.","title":"Final Remark"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. The first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. 1. Cosmic Velocities: Definitions and Derivations 1.1 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the velocity required for an object to enter a stable orbit around a celestial body without any additional propulsion. It is derived from balancing the centrifugal force (due to circular motion) with the gravitational force acting on the object. The formula for the orbital velocity is: \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\(M\\) is the mass of the celestial body, - \\(R\\) is the radius of the celestial body. 1.2 Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the velocity required for an object to break free from a celestial body's gravitational influence, assuming no other forces (like atmospheric drag) are acting on it. It is derived from the energy required to escape the gravitational field. The escape velocity is given by: \\[ v_2 = \\sqrt{\\frac{2GM}{R}} \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is the radius of the celestial body. 1.3 Third Cosmic Velocity (Heliocentric Escape Velocity) The third cosmic velocity is the velocity required for an object to escape the gravitational influence of the Sun (i.e., to leave the Solar System). It is derived from the combination of the escape velocity from Earth and the velocity required to overcome the Sun's gravity. The third cosmic velocity is given by: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{Sun}}^2} \\] where: - \\(v_2\\) is the second cosmic velocity (escape velocity from the Earth), - \\(v_{\\text{Sun}}\\) is the orbital velocity of the Earth around the Sun, which is approximately \\(29.78 \\, \\text{km/s}\\) . 1.4 Mathematical Parameters Affecting Cosmic Velocities The velocities depend on: - The mass ( \\(M\\) ) of the celestial body, - The radius ( \\(R\\) ) of the celestial body, - The gravitational constant ( \\(G\\) ), - The orbital velocity of Earth around the Sun for the third cosmic velocity. 2. Calculation and Values for Earth 2.1 First Cosmic Velocity for Earth For Earth, we use the following values: - \\(M_{\\text{Earth}} = 5.972 \\times 10^{24} \\, \\text{kg}\\) , - \\(R_{\\text{Earth}} = 6.378 \\times 10^{6} \\, \\text{m}\\) . Substituting into the formula for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.378 \\times 10^{6}}} \\] This yields: \\[ v_1 \\approx 7.12 \\, \\text{km/s} \\] 2.2 Second Cosmic Velocity for Earth Using the same values for Earth, the second cosmic velocity is: \\[ v_2 = \\sqrt{\\frac{2(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.378 \\times 10^{6}}} \\] This gives: \\[ v_2 \\approx 11.2 \\, \\text{km/s} \\] 2.3 Third Cosmic Velocity for Earth To calculate the third cosmic velocity, we use the value of the second cosmic velocity for Earth and the orbital velocity of the Earth around the Sun ( \\(v_{\\text{Sun}} = 29.78 \\, \\text{km/s}\\) ): \\[ v_3 = \\sqrt{(11.2)^2 + (29.78)^2} \\] This yields: \\[ v_3 \\approx 32.2 \\, \\text{km/s} \\] 3. \ud83d\ude80 Derivation of the First and Second Cosmic Velocities 1\ufe0f\u20e3 First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the minimum speed an object needs to stay in a stable circular orbit near the Earth's surface without propulsion. Using Newton\u2019s law of gravitation and centripetal force: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\Rightarrow \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) and solve for \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] Where: \\(G\\) : Gravitational constant \\(M\\) : Mass of the planet (e.g., Earth) \\(r\\) : Radius from center of the planet \\(v\\) : First cosmic (orbital) velocity 2\ufe0f\u20e3 Second Cosmic Velocity (Escape Velocity) Escape velocity is the minimum speed needed for an object to escape a planet's gravitational field without further propulsion. Using conservation of energy: \\[ \\frac{1}{2} m v^2 - \\frac{G M m}{r} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2 G M}{r}} \\] This is higher than the first cosmic velocity by a factor of \\(\\sqrt{2}\\) : \\[ v_{\\text{escape}} = \\sqrt{2} \\cdot v_{\\text{orbital}} \\] \ud83d\udcd8 Summary First Cosmic Velocity: \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Second Cosmic Velocity: \\(v_2 = \\sqrt{\\frac{2 G M}{r}}\\) Relationship: \\(v_2 = \\sqrt{2} \\cdot v_1\\) 4. Comparison with Other Celestial Bodies 4.1 Moon For the Moon, the mass and radius are as follows: - \\(M_{\\text{Moon}} = 7.347 \\times 10^{22} \\, \\text{kg}\\) , - \\(R_{\\text{Moon}} = 1.737 \\times 10^{6} \\, \\text{m}\\) . Using the formulas for \\(v_1\\) and \\(v_2\\) , we can calculate the first and second cosmic velocities for the Moon. The third cosmic velocity would be the same as for Earth, since the Moon is orbiting the Earth, and the third cosmic velocity is primarily influenced by the Earth's position relative to the Sun. 4.2 Mars For Mars: - \\(M_{\\text{Mars}} = 6.4171 \\times 10^{23} \\, \\text{kg}\\) , - \\(R_{\\text{Mars}} = 3.396 \\times 10^{6} \\, \\text{m}\\) . Again, using the formulas for \\(v_1\\) and \\(v_2\\) , we can compute these values for Mars. 4.3 Jupiter For Jupiter: - \\(M_{\\text{Jupiter}} = 1.898 \\times 10^{27} \\, \\text{kg}\\) , - \\(R_{\\text{Jupiter}} = 6.991 \\times 10^{7} \\, \\text{m}\\) . Similarly, the first and second cosmic velocities for Jupiter can be calculated, and the third cosmic velocity will again be affected by the position of Jupiter relative to the Sun. import matplotlib.pyplot as plt bodies = [\"Moon\", \"Earth\", \"Mars\", \"Jupiter\"] v1 = [1.68, 7.9, 3.6, 42.1] v2 = [2.38, 11.2, 5.0, 59.5] x = range(len(bodies)) plt.bar(x, v1, width=0.4, label=\"1st Cosmic Velocity\", align='center') plt.bar([i + 0.4 for i in x], v2, width=0.4, label=\"2nd Cosmic Velocity\", align='center') plt.xticks([i + 0.2 for i in x], bodies) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Comparison of Cosmic Velocities\") plt.legend() plt.grid(axis='y') plt.show() Visit My Collab 5. Importance in Space Exploration 5.1 Launching Satellites The first cosmic velocity is important for placing satellites into stable orbits around Earth. Achieving this velocity ensures that the satellite remains in orbit without falling back to the surface. 5.2 Missions to Other Planets The second cosmic velocity is crucial for missions aiming to escape Earth's gravitational influence, such as interplanetary missions. This velocity allows spacecraft to escape Earth\u2019s gravity and travel to other planets. 5.3 Potential for Interstellar Travel The third cosmic velocity is important when considering missions that aim to leave the Solar System entirely. While this velocity is beyond current technological capabilities, it is theoretically important for interstellar travel. 6. Conclusion Understanding the first, second, and third cosmic velocities is essential for modern space exploration, as these velocities determine the thresholds for orbital dynamics, escape, and interstellar missions.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. The first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-cosmic-velocities-definitions-and-derivations","text":"","title":"1. Cosmic Velocities: Definitions and Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#11-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the velocity required for an object to enter a stable orbit around a celestial body without any additional propulsion. It is derived from balancing the centrifugal force (due to circular motion) with the gravitational force acting on the object. The formula for the orbital velocity is: \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\(M\\) is the mass of the celestial body, - \\(R\\) is the radius of the celestial body.","title":"1.1 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#12-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the velocity required for an object to break free from a celestial body's gravitational influence, assuming no other forces (like atmospheric drag) are acting on it. It is derived from the energy required to escape the gravitational field. The escape velocity is given by: \\[ v_2 = \\sqrt{\\frac{2GM}{R}} \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(R\\) is the radius of the celestial body.","title":"1.2 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#13-third-cosmic-velocity-heliocentric-escape-velocity","text":"The third cosmic velocity is the velocity required for an object to escape the gravitational influence of the Sun (i.e., to leave the Solar System). It is derived from the combination of the escape velocity from Earth and the velocity required to overcome the Sun's gravity. The third cosmic velocity is given by: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{Sun}}^2} \\] where: - \\(v_2\\) is the second cosmic velocity (escape velocity from the Earth), - \\(v_{\\text{Sun}}\\) is the orbital velocity of the Earth around the Sun, which is approximately \\(29.78 \\, \\text{km/s}\\) .","title":"1.3 Third Cosmic Velocity (Heliocentric Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#14-mathematical-parameters-affecting-cosmic-velocities","text":"The velocities depend on: - The mass ( \\(M\\) ) of the celestial body, - The radius ( \\(R\\) ) of the celestial body, - The gravitational constant ( \\(G\\) ), - The orbital velocity of Earth around the Sun for the third cosmic velocity.","title":"1.4 Mathematical Parameters Affecting Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-calculation-and-values-for-earth","text":"","title":"2. Calculation and Values for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity-for-earth","text":"For Earth, we use the following values: - \\(M_{\\text{Earth}} = 5.972 \\times 10^{24} \\, \\text{kg}\\) , - \\(R_{\\text{Earth}} = 6.378 \\times 10^{6} \\, \\text{m}\\) . Substituting into the formula for \\(v_1\\) : \\[ v_1 = \\sqrt{\\frac{(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.378 \\times 10^{6}}} \\] This yields: \\[ v_1 \\approx 7.12 \\, \\text{km/s} \\]","title":"2.1 First Cosmic Velocity for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity-for-earth","text":"Using the same values for Earth, the second cosmic velocity is: \\[ v_2 = \\sqrt{\\frac{2(6.67430 \\times 10^{-11}) (5.972 \\times 10^{24})}{6.378 \\times 10^{6}}} \\] This gives: \\[ v_2 \\approx 11.2 \\, \\text{km/s} \\]","title":"2.2 Second Cosmic Velocity for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-for-earth","text":"To calculate the third cosmic velocity, we use the value of the second cosmic velocity for Earth and the orbital velocity of the Earth around the Sun ( \\(v_{\\text{Sun}} = 29.78 \\, \\text{km/s}\\) ): \\[ v_3 = \\sqrt{(11.2)^2 + (29.78)^2} \\] This yields: \\[ v_3 \\approx 32.2 \\, \\text{km/s} \\]","title":"2.3 Third Cosmic Velocity for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-derivation-of-the-first-and-second-cosmic-velocities","text":"","title":"3. \ud83d\ude80 Derivation of the First and Second Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum speed an object needs to stay in a stable circular orbit near the Earth's surface without propulsion. Using Newton\u2019s law of gravitation and centripetal force: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\Rightarrow \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Cancel \\(m\\) and solve for \\(v\\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] Where: \\(G\\) : Gravitational constant \\(M\\) : Mass of the planet (e.g., Earth) \\(r\\) : Radius from center of the planet \\(v\\) : First cosmic (orbital) velocity","title":"1\ufe0f\u20e3 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"Escape velocity is the minimum speed needed for an object to escape a planet's gravitational field without further propulsion. Using conservation of energy: \\[ \\frac{1}{2} m v^2 - \\frac{G M m}{r} = 0 \\] Solving for \\(v\\) : \\[ v = \\sqrt{\\frac{2 G M}{r}} \\] This is higher than the first cosmic velocity by a factor of \\(\\sqrt{2}\\) : \\[ v_{\\text{escape}} = \\sqrt{2} \\cdot v_{\\text{orbital}} \\]","title":"2\ufe0f\u20e3 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#summary","text":"First Cosmic Velocity: \\(v_1 = \\sqrt{\\frac{G M}{r}}\\) Second Cosmic Velocity: \\(v_2 = \\sqrt{\\frac{2 G M}{r}}\\) Relationship: \\(v_2 = \\sqrt{2} \\cdot v_1\\)","title":"\ud83d\udcd8 Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-comparison-with-other-celestial-bodies","text":"","title":"4. Comparison with Other Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#41-moon","text":"For the Moon, the mass and radius are as follows: - \\(M_{\\text{Moon}} = 7.347 \\times 10^{22} \\, \\text{kg}\\) , - \\(R_{\\text{Moon}} = 1.737 \\times 10^{6} \\, \\text{m}\\) . Using the formulas for \\(v_1\\) and \\(v_2\\) , we can calculate the first and second cosmic velocities for the Moon. The third cosmic velocity would be the same as for Earth, since the Moon is orbiting the Earth, and the third cosmic velocity is primarily influenced by the Earth's position relative to the Sun.","title":"4.1 Moon"},{"location":"1%20Physics/2%20Gravity/Problem_2/#42-mars","text":"For Mars: - \\(M_{\\text{Mars}} = 6.4171 \\times 10^{23} \\, \\text{kg}\\) , - \\(R_{\\text{Mars}} = 3.396 \\times 10^{6} \\, \\text{m}\\) . Again, using the formulas for \\(v_1\\) and \\(v_2\\) , we can compute these values for Mars.","title":"4.2 Mars"},{"location":"1%20Physics/2%20Gravity/Problem_2/#43-jupiter","text":"For Jupiter: - \\(M_{\\text{Jupiter}} = 1.898 \\times 10^{27} \\, \\text{kg}\\) , - \\(R_{\\text{Jupiter}} = 6.991 \\times 10^{7} \\, \\text{m}\\) . Similarly, the first and second cosmic velocities for Jupiter can be calculated, and the third cosmic velocity will again be affected by the position of Jupiter relative to the Sun. import matplotlib.pyplot as plt bodies = [\"Moon\", \"Earth\", \"Mars\", \"Jupiter\"] v1 = [1.68, 7.9, 3.6, 42.1] v2 = [2.38, 11.2, 5.0, 59.5] x = range(len(bodies)) plt.bar(x, v1, width=0.4, label=\"1st Cosmic Velocity\", align='center') plt.bar([i + 0.4 for i in x], v2, width=0.4, label=\"2nd Cosmic Velocity\", align='center') plt.xticks([i + 0.2 for i in x], bodies) plt.ylabel(\"Velocity (km/s)\") plt.title(\"Comparison of Cosmic Velocities\") plt.legend() plt.grid(axis='y') plt.show() Visit My Collab","title":"4.3 Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-importance-in-space-exploration","text":"","title":"5. Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#51-launching-satellites","text":"The first cosmic velocity is important for placing satellites into stable orbits around Earth. Achieving this velocity ensures that the satellite remains in orbit without falling back to the surface.","title":"5.1 Launching Satellites"},{"location":"1%20Physics/2%20Gravity/Problem_2/#52-missions-to-other-planets","text":"The second cosmic velocity is crucial for missions aiming to escape Earth's gravitational influence, such as interplanetary missions. This velocity allows spacecraft to escape Earth\u2019s gravity and travel to other planets.","title":"5.2 Missions to Other Planets"},{"location":"1%20Physics/2%20Gravity/Problem_2/#53-potential-for-interstellar-travel","text":"The third cosmic velocity is important when considering missions that aim to leave the Solar System entirely. While this velocity is beyond current technological capabilities, it is theoretically important for interstellar travel.","title":"5.3 Potential for Interstellar Travel"},{"location":"1%20Physics/2%20Gravity/Problem_2/#6-conclusion","text":"Understanding the first, second, and third cosmic velocities is essential for modern space exploration, as these velocities determine the thresholds for orbital dynamics, escape, and interstellar missions.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. 1. Possible Trajectories of a Payload 1.1 Types of Trajectories When a payload is released from a moving object near Earth, its trajectory depends on the initial velocity and position. The main types of trajectories are: - Parabolic Trajectory: The object follows a parabolic path when its velocity is less than the escape velocity but enough to travel away from the Earth. - Hyperbolic Trajectory: The object follows a hyperbolic trajectory when its velocity is greater than the escape velocity. - Elliptical Trajectory: The object follows an elliptical path when the velocity is not enough to escape Earth's gravity, resulting in an orbit. 1.2 Deriving the Equation of Motion The motion of the payload can be described by Newton\u2019s Law of Gravitation and the equations of motion. The gravitational force between two objects (Earth and the payload) is given by: \\[ F = \\frac{GMm}{r^2} \\] where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), - \\(m\\) is the mass of the payload, - \\(r\\) is the distance between the payload and the center of Earth. The equations of motion can then be derived from this gravitational force, and numerical methods are used to simulate the motion over time. import numpy as np import matplotlib.pyplot as plt # \u0413\u0440\u0430\u0432\u0438\u0442\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b G = 6.67430e-11 # \u043c^3 \u043a\u0433^-1 \u0441^-2 M = 5.972e24 # \u043c\u0430\u0441\u0441\u0430 \u0417\u0435\u043c\u043b\u0438, \u043a\u0433 R_earth = 6.371e6 # \u0440\u0430\u0434\u0438\u0443\u0441 \u0417\u0435\u043c\u043b\u0438, \u043c # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f altitude = 800e3 # 800 \u043a\u043c \u043d\u0430\u0434 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e r0 = np.array([R_earth + altitude, 0]) # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u043f\u0440\u0430\u0432\u0430 \u043e\u0442 \u0417\u0435\u043c\u043b\u0438 velocities = np.arange(5e3, 13.5e3, 0.5e3) # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u043e\u0442 5 \u0434\u043e 13 \u043a\u043c/\u0441 # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b dt = 1 # \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0441) T = 10000 # \u043e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f (\u0441) steps = int(T / dt) # \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 fig, ax = plt.subplots(figsize=(8, 8)) theta = np.linspace(0, 2 * np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, 'b', label='\u0417\u0435\u043c\u043b\u044f', alpha=0.5) # \u0421\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u044f \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 colors = plt.cm.viridis(np.linspace(0, 1, len(velocities))) for v0, color in zip(velocities, colors): r = r0.copy() v = np.array([0, v0]) traj_x, traj_y = [], [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: # \u0435\u0441\u043b\u0438 \u0433\u0440\u0443\u0437 \u0432\u0440\u0435\u0437\u0430\u043b\u0441\u044f \u0432 \u0417\u0435\u043c\u043b\u044e break a = -G * M * r / r_mag**3 v += a * dt r += v * dt traj_x.append(r[0]) traj_y.append(r[1]) ax.plot(traj_x, traj_y, label=f'{v0/1000:.1f} \u043a\u043c/\u0441', color=color) # \u041e\u0444\u043e\u0440\u043c\u043b\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 ax.set_aspect('equal') ax.set_xlim(-2e7, 2e7) ax.set_ylim(-2e7, 2e7) ax.set_xlabel('x (\u043c)') ax.set_ylabel('y (\u043c)') ax.set_title('\u0422\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u0433\u0440\u0443\u0437\u0430 \u043f\u0440\u0438 \u0441\u0431\u0440\u043e\u0441\u0435 \u0441 \u0432\u044b\u0441\u043e\u0442\u044b 800 \u043a\u043c') ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show() Visit My Collab 2. Numerical Analysis of the Payload's Path 2.1 Initial Conditions and Setup For the simulation, we set the initial position of the payload at an altitude of 800 km above Earth's surface. The Earth's radius is approximately 6371 km, so the initial distance from the center of Earth is: \\[ r_{\\text{initial}} = 6371 \\, \\text{km} + 800 \\, \\text{km} = 7171 \\, \\text{km} \\] We also release the payload with different initial velocities (5 km/s, 5.5 km/s, ..., up to 13 km/s). Each velocity results in a different trajectory, and we will simulate and visualize these paths. 2.2 Equations of Motion The equations of motion are based on Newton's second law: \\[ m \\ddot{r} = -\\frac{GMm}{r^2} \\] where \\(\\ddot{r}\\) is the acceleration, and the negative sign indicates that the force is attractive (towards the Earth). The simulation involves solving this differential equation numerically using methods like Euler's method or the Runge-Kutta method. 3. Computational Tool and Visualization A computational tool can be used to simulate and visualize the trajectory of the payload under Earth's gravity. This involves solving the equations of motion numerically for different initial velocities. The results will be plotted as the distance from Earth's center over time. 3.1 Explanation of the Python Code The simulation involves updating the position and velocity of the payload at each time step using the gravitational force equation. The payload is released at 800 km above Earth's surface with varying initial velocities (from 5 km/s to 13 km/s). The Earth is represented as a reference point at the surface level, and the trajectory is computed numerically. 3.2 Visualizing the Trajectories The plot generated from the simulation shows the trajectories of the payload for different initial velocities. The trajectories are plotted as a function of time, with the Earth's surface marked as a reference. # --- Imports --- import numpy as np import matplotlib.pyplot as plt # --- Physical Constants --- G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 AU = 1.496e11 # 1 astronomical unit (average Earth-Sun distance), m day = 24 * 3600 # seconds in one day year = 365.25 * day # seconds in one year # --- Kepler's Third Law Formula --- # T^2 = (4\u03c0\u00b2/GM) * R\u00b3 # => M = (4\u03c0\u00b2 R\u00b3) / (G T\u00b2) def mass_from_orbit(R, T): return (4 * np.pi**2 * R**3) / (G * T**2) # --- 1. Finding the Mass of the Sun from Earth's Orbit --- R_earth_orbit = AU # Earth's orbit radius (m) T_earth_orbit = year # Earth's orbital period (s) M_sun = mass_from_orbit(R_earth_orbit, T_earth_orbit) print(f\"\u2600\ufe0f Mass of the Sun \u2248 {M_sun:.2e} kg\") # --- 2. Finding the Mass of the Earth from the Moon's Orbit --- # Parameters of the Moon's orbit: R_moon_orbit = 384400e3 # average distance to the Moon (m) T_moon_orbit = 27.32 * day # Moon's orbital period (s) M_earth = mass_from_orbit(R_moon_orbit, T_moon_orbit) print(f\"\ud83c\udf0d Mass of the Earth \u2248 {M_earth:.2e} kg\") # --- 3. Plotting T\u00b2 vs R\u00b3 --- # Example planetary data (Solar System planets) radii = np.array([ 57.9e9, # Mercury 108.2e9, # Venus 149.6e9, # Earth 227.9e9, # Mars 778.5e9, # Jupiter 1433e9, # Saturn 2877e9, # Uranus 4503e9 # Neptune ]) periods_days = np.array([ 88, # Mercury 224.7, # Venus 365.25, # Earth 687, # Mars 4331, # Jupiter 10747, # Saturn 30589, # Uranus 59800 # Neptune ]) # Convert to seconds periods_seconds = periods_days * day # Calculate T\u00b2 and R\u00b3 T_squared = periods_seconds**2 R_cubed = radii**3 # --- Plot T\u00b2 vs R\u00b3 --- plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, 'o-', label=\"Planets\") plt.xlabel('$R^3$ (m\u00b3)', fontsize=12) plt.ylabel('$T^2$ (s\u00b2)', fontsize=12) plt.title('Dependence of $T^2$ on $R^3$ (Kepler\\'s Third Law)', fontsize=14) plt.grid(True) plt.legend() plt.show() # --- 4. Checking the linear relation (log-log plot) --- plt.figure(figsize=(8,6)) plt.plot(np.log10(R_cubed), np.log10(T_squared), 'o-', label=\"Planets\") plt.xlabel('log($R^3$)', fontsize=12) plt.ylabel('log($T^2$)', fontsize=12) plt.title('Log-Log Plot: $T^2$ vs $R^3$', fontsize=14) plt.grid(True) plt.legend() plt.show() Visit My Collab 4. Discussion on Orbital Insertion, Reentry, and Escape Orbital Insertion: If the payload's initial velocity is below escape velocity but high enough to prevent it from falling back to Earth, it will enter an elliptical orbit. Reentry: If the velocity is too low, the payload will follow a parabolic trajectory and eventually reenter Earth's atmosphere. Escape Velocity: If the initial velocity is equal to or greater than the escape velocity, the payload will follow a hyperbolic trajectory and escape Earth's gravitational influence. 5. Conclusion This analysis and simulation provide a clear understanding of how a payload's initial velocity affects its trajectory when released near Earth. By adjusting the initial conditions, we can model different space missions, such as satellite deployment or payload return.","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-possible-trajectories-of-a-payload","text":"","title":"1. Possible Trajectories of a Payload"},{"location":"1%20Physics/2%20Gravity/Problem_3/#11-types-of-trajectories","text":"When a payload is released from a moving object near Earth, its trajectory depends on the initial velocity and position. The main types of trajectories are: - Parabolic Trajectory: The object follows a parabolic path when its velocity is less than the escape velocity but enough to travel away from the Earth. - Hyperbolic Trajectory: The object follows a hyperbolic trajectory when its velocity is greater than the escape velocity. - Elliptical Trajectory: The object follows an elliptical path when the velocity is not enough to escape Earth's gravity, resulting in an orbit.","title":"1.1 Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#12-deriving-the-equation-of-motion","text":"The motion of the payload can be described by Newton\u2019s Law of Gravitation and the equations of motion. The gravitational force between two objects (Earth and the payload) is given by: \\[ F = \\frac{GMm}{r^2} \\] where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ), - \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), - \\(m\\) is the mass of the payload, - \\(r\\) is the distance between the payload and the center of Earth. The equations of motion can then be derived from this gravitational force, and numerical methods are used to simulate the motion over time. import numpy as np import matplotlib.pyplot as plt # \u0413\u0440\u0430\u0432\u0438\u0442\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0435 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b G = 6.67430e-11 # \u043c^3 \u043a\u0433^-1 \u0441^-2 M = 5.972e24 # \u043c\u0430\u0441\u0441\u0430 \u0417\u0435\u043c\u043b\u0438, \u043a\u0433 R_earth = 6.371e6 # \u0440\u0430\u0434\u0438\u0443\u0441 \u0417\u0435\u043c\u043b\u0438, \u043c # \u041d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0435 \u0443\u0441\u043b\u043e\u0432\u0438\u044f altitude = 800e3 # 800 \u043a\u043c \u043d\u0430\u0434 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e r0 = np.array([R_earth + altitude, 0]) # \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u0441\u043f\u0440\u0430\u0432\u0430 \u043e\u0442 \u0417\u0435\u043c\u043b\u0438 velocities = np.arange(5e3, 13.5e3, 0.5e3) # \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 \u043e\u0442 5 \u0434\u043e 13 \u043a\u043c/\u0441 # \u0412\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b dt = 1 # \u0448\u0430\u0433 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 (\u0441) T = 10000 # \u043e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f (\u0441) steps = int(T / dt) # \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 fig, ax = plt.subplots(figsize=(8, 8)) theta = np.linspace(0, 2 * np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) ax.fill(earth_x, earth_y, 'b', label='\u0417\u0435\u043c\u043b\u044f', alpha=0.5) # \u0421\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u044f \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u0438 colors = plt.cm.viridis(np.linspace(0, 1, len(velocities))) for v0, color in zip(velocities, colors): r = r0.copy() v = np.array([0, v0]) traj_x, traj_y = [], [] for _ in range(steps): r_mag = np.linalg.norm(r) if r_mag < R_earth: # \u0435\u0441\u043b\u0438 \u0433\u0440\u0443\u0437 \u0432\u0440\u0435\u0437\u0430\u043b\u0441\u044f \u0432 \u0417\u0435\u043c\u043b\u044e break a = -G * M * r / r_mag**3 v += a * dt r += v * dt traj_x.append(r[0]) traj_y.append(r[1]) ax.plot(traj_x, traj_y, label=f'{v0/1000:.1f} \u043a\u043c/\u0441', color=color) # \u041e\u0444\u043e\u0440\u043c\u043b\u0435\u043d\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0430 ax.set_aspect('equal') ax.set_xlim(-2e7, 2e7) ax.set_ylim(-2e7, 2e7) ax.set_xlabel('x (\u043c)') ax.set_ylabel('y (\u043c)') ax.set_title('\u0422\u0440\u0430\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u0433\u0440\u0443\u0437\u0430 \u043f\u0440\u0438 \u0441\u0431\u0440\u043e\u0441\u0435 \u0441 \u0432\u044b\u0441\u043e\u0442\u044b 800 \u043a\u043c') ax.legend(loc='upper right', fontsize='small') plt.grid(True) plt.tight_layout() plt.show() Visit My Collab","title":"1.2 Deriving the Equation of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-analysis-of-the-payloads-path","text":"","title":"2. Numerical Analysis of the Payload's Path"},{"location":"1%20Physics/2%20Gravity/Problem_3/#21-initial-conditions-and-setup","text":"For the simulation, we set the initial position of the payload at an altitude of 800 km above Earth's surface. The Earth's radius is approximately 6371 km, so the initial distance from the center of Earth is: \\[ r_{\\text{initial}} = 6371 \\, \\text{km} + 800 \\, \\text{km} = 7171 \\, \\text{km} \\] We also release the payload with different initial velocities (5 km/s, 5.5 km/s, ..., up to 13 km/s). Each velocity results in a different trajectory, and we will simulate and visualize these paths.","title":"2.1 Initial Conditions and Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#22-equations-of-motion","text":"The equations of motion are based on Newton's second law: \\[ m \\ddot{r} = -\\frac{GMm}{r^2} \\] where \\(\\ddot{r}\\) is the acceleration, and the negative sign indicates that the force is attractive (towards the Earth). The simulation involves solving this differential equation numerically using methods like Euler's method or the Runge-Kutta method.","title":"2.2 Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-computational-tool-and-visualization","text":"A computational tool can be used to simulate and visualize the trajectory of the payload under Earth's gravity. This involves solving the equations of motion numerically for different initial velocities. The results will be plotted as the distance from Earth's center over time.","title":"3. Computational Tool and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#31-explanation-of-the-python-code","text":"The simulation involves updating the position and velocity of the payload at each time step using the gravitational force equation. The payload is released at 800 km above Earth's surface with varying initial velocities (from 5 km/s to 13 km/s). The Earth is represented as a reference point at the surface level, and the trajectory is computed numerically.","title":"3.1 Explanation of the Python Code"},{"location":"1%20Physics/2%20Gravity/Problem_3/#32-visualizing-the-trajectories","text":"The plot generated from the simulation shows the trajectories of the payload for different initial velocities. The trajectories are plotted as a function of time, with the Earth's surface marked as a reference. # --- Imports --- import numpy as np import matplotlib.pyplot as plt # --- Physical Constants --- G = 6.67430e-11 # gravitational constant, m^3 kg^-1 s^-2 AU = 1.496e11 # 1 astronomical unit (average Earth-Sun distance), m day = 24 * 3600 # seconds in one day year = 365.25 * day # seconds in one year # --- Kepler's Third Law Formula --- # T^2 = (4\u03c0\u00b2/GM) * R\u00b3 # => M = (4\u03c0\u00b2 R\u00b3) / (G T\u00b2) def mass_from_orbit(R, T): return (4 * np.pi**2 * R**3) / (G * T**2) # --- 1. Finding the Mass of the Sun from Earth's Orbit --- R_earth_orbit = AU # Earth's orbit radius (m) T_earth_orbit = year # Earth's orbital period (s) M_sun = mass_from_orbit(R_earth_orbit, T_earth_orbit) print(f\"\u2600\ufe0f Mass of the Sun \u2248 {M_sun:.2e} kg\") # --- 2. Finding the Mass of the Earth from the Moon's Orbit --- # Parameters of the Moon's orbit: R_moon_orbit = 384400e3 # average distance to the Moon (m) T_moon_orbit = 27.32 * day # Moon's orbital period (s) M_earth = mass_from_orbit(R_moon_orbit, T_moon_orbit) print(f\"\ud83c\udf0d Mass of the Earth \u2248 {M_earth:.2e} kg\") # --- 3. Plotting T\u00b2 vs R\u00b3 --- # Example planetary data (Solar System planets) radii = np.array([ 57.9e9, # Mercury 108.2e9, # Venus 149.6e9, # Earth 227.9e9, # Mars 778.5e9, # Jupiter 1433e9, # Saturn 2877e9, # Uranus 4503e9 # Neptune ]) periods_days = np.array([ 88, # Mercury 224.7, # Venus 365.25, # Earth 687, # Mars 4331, # Jupiter 10747, # Saturn 30589, # Uranus 59800 # Neptune ]) # Convert to seconds periods_seconds = periods_days * day # Calculate T\u00b2 and R\u00b3 T_squared = periods_seconds**2 R_cubed = radii**3 # --- Plot T\u00b2 vs R\u00b3 --- plt.figure(figsize=(8,6)) plt.plot(R_cubed, T_squared, 'o-', label=\"Planets\") plt.xlabel('$R^3$ (m\u00b3)', fontsize=12) plt.ylabel('$T^2$ (s\u00b2)', fontsize=12) plt.title('Dependence of $T^2$ on $R^3$ (Kepler\\'s Third Law)', fontsize=14) plt.grid(True) plt.legend() plt.show() # --- 4. Checking the linear relation (log-log plot) --- plt.figure(figsize=(8,6)) plt.plot(np.log10(R_cubed), np.log10(T_squared), 'o-', label=\"Planets\") plt.xlabel('log($R^3$)', fontsize=12) plt.ylabel('log($T^2$)', fontsize=12) plt.title('Log-Log Plot: $T^2$ vs $R^3$', fontsize=14) plt.grid(True) plt.legend() plt.show() Visit My Collab","title":"3.2 Visualizing the Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-discussion-on-orbital-insertion-reentry-and-escape","text":"Orbital Insertion: If the payload's initial velocity is below escape velocity but high enough to prevent it from falling back to Earth, it will enter an elliptical orbit. Reentry: If the velocity is too low, the payload will follow a parabolic trajectory and eventually reenter Earth's atmosphere. Escape Velocity: If the initial velocity is equal to or greater than the escape velocity, the payload will follow a hyperbolic trajectory and escape Earth's gravitational influence.","title":"4. Discussion on Orbital Insertion, Reentry, and Escape"},{"location":"1%20Physics/2%20Gravity/Problem_3/#5-conclusion","text":"This analysis and simulation provide a clear understanding of how a payload's initial velocity affects its trajectory when released near Earth. By adjusting the initial conditions, we can model different space missions, such as satellite deployment or payload return.","title":"5. Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Wave Interference Patterns on a Water Surface \ud83d\udccc Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easily observed as ripples from different points meet and form distinctive patterns. Understanding these patterns helps us grasp the principle of superposition , the influence of phase differences , and the effects of multiple wave sources . We explore this visually using wave simulations for: One wave source Two coherent sources Multiple sources placed on a regular polygon (e.g., triangle, square, pentagon) \ud83d\udcd0 Wave Equation for a Circular Disturbance A circular wave on a water surface from a single point source at \\((x_0, y_0)\\) is modeled as: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cdot \\cos(k r - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : Displacement at position \\((x, y)\\) and time \\(t\\) \\(A\\) : Amplitude of the wave \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number \\(\\omega = 2\\pi f\\) : Angular frequency \\(\\phi\\) : Initial phase \ud83d\udca1 Superposition of Multiple Sources When \\(N\\) sources emit coherent waves, the total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i^{th}\\) source. \ud83e\uddea Python Simulation Code (Snippet) import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # --- Grid Setup --- size = 200 x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Dalga Parametreleri --- wavelength = 2 speed = 1 k = 2 * np.pi / wavelength omega = k * speed # --- Kaynaklar --- source1 = (-3, 0) source2 = (3, 0) # --- Animasyon Ayarlar\u0131 --- fig, ax = plt.subplots(figsize=(6,6)) heatmap = ax.imshow(np.zeros((size, size)), cmap='coolwarm', vmin=-1, vmax=1, extent=(-10,10,-10,10)) ax.set_title(\"Two Source Interference Pattern\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # --- Frame G\u00fcncelleme --- def update(t): r1 = np.sqrt((X - source1[0])**2 + (Y - source1[1])**2) r2 = np.sqrt((X - source2[0])**2 + (Y - source2[1])**2) wave1 = np.sin(k * r1 - omega * t) / (r1 + 1e-6) wave2 = np.sin(k * r2 - omega * t) / (r2 + 1e-6) Z = wave1 + wave2 heatmap.set_data(Z) return [heatmap] ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 60), interval=100) # --- Colab i\u00e7in animasyonu g\u00f6ster --- HTML(ani.to_jshtml()) Visit My Collab import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from mpl_toolkits.mplot3d import Axes3D # --- Grid Setup --- size = 100 # smaller size for faster rendering x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Wave Function --- def wave_source(X, Y, x0, y0, t, wavelength=1, speed=1): r = np.sqrt((X - x0)**2 + (Y - y0)**2) k = 2 * np.pi / wavelength omega = k * speed return np.sin(k * r - omega * t) / (r + 1e-6) # --- Source Patterns --- def get_sources(pattern): if pattern == \"one\": return [(0, 0)] elif pattern == \"two\": return [(-3, 0), (3, 0)] elif pattern == \"triangle\": R = 4 angles = np.linspace(0, 2*np.pi, 4)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] elif pattern == \"pentagon\": R = 5 angles = np.linspace(0, 2*np.pi, 6)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] patterns = [\"one\", \"two\", \"triangle\", \"pentagon\"] # --- Plot Setup --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') Z = np.zeros_like(X) surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') title = ax.set_title(\"\") # --- Frame Update Function --- def update(frame): pattern = patterns[(frame // 20) % len(patterns)] t = frame % 20 sources = get_sources(pattern) Z = sum(wave_source(X, Y, sx, sy, t) for sx, sy in sources) ax.clear() # careful: only light clearing surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') ax.set_title(f\"Wave Interference: {pattern.capitalize()} ({len(sources)} source{'s' if len(sources) > 1 else ''})\") return surf, # --- Create Animation --- ani = animation.FuncAnimation(fig, update, frames=80, interval=100, blit=False) # --- Save Animation --- ani.save('/content/wave_interference_3d.gif', writer='pillow') plt.close() print(\"\u2705 3D GIF saved as /content/wave_interference_3d.gif\") \ud83d\udcca Visualizations \u2705 One Source \u2014 Radial Symmetry Circular ripples expanding outward from the center. No interference is observed since there is only one wavefront . The wave pattern is described by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cdot \\cos(k r - \\omega t + \\phi) \\] Where: \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the radial distance from the source. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number. \\(\\omega = 2\\pi f\\) is the angular frequency. \u2705 Two Sources \u2014 Classic Interference Alternating constructive and destructive interference zones appear. Central regions exhibit lines of maxima and minima , depending on the relative phase and path difference. The total displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) \\] Constructive interference occurs when: \\[ \\Delta r = n \\lambda, \\quad n \\in \\mathbb{Z} \\] Destructive interference occurs when: \\[ \\Delta r = \\left(n + \\frac{1}{2}\\right)\\lambda \\] \u2705 Triangle or Pentagon Configuration Multiple coherent sources create complex and symmetric interference patterns . Patterns form an intricate lattice due to overlapping wavefronts. High symmetry and periodicity in amplification (constructive interference) and cancellation (destructive interference) regions. The total displacement from \\(N\\) sources: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where each \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i^{\\text{th}}\\) source. \ud83d\udccc These visualizations help reinforce key wave phenomena including superposition, phase difference, and spatial symmetry.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Wave Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easily observed as ripples from different points meet and form distinctive patterns. Understanding these patterns helps us grasp the principle of superposition , the influence of phase differences , and the effects of multiple wave sources . We explore this visually using wave simulations for: One wave source Two coherent sources Multiple sources placed on a regular polygon (e.g., triangle, square, pentagon)","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation-for-a-circular-disturbance","text":"A circular wave on a water surface from a single point source at \\((x_0, y_0)\\) is modeled as: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cdot \\cos(k r - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) : Displacement at position \\((x, y)\\) and time \\(t\\) \\(A\\) : Amplitude of the wave \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) : Distance from source \\(k = \\frac{2\\pi}{\\lambda}\\) : Wave number \\(\\omega = 2\\pi f\\) : Angular frequency \\(\\phi\\) : Initial phase","title":"\ud83d\udcd0 Wave Equation for a Circular Disturbance"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-multiple-sources","text":"When \\(N\\) sources emit coherent waves, the total displacement is: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i^{th}\\) source.","title":"\ud83d\udca1 Superposition of Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation-code-snippet","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # --- Grid Setup --- size = 200 x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Dalga Parametreleri --- wavelength = 2 speed = 1 k = 2 * np.pi / wavelength omega = k * speed # --- Kaynaklar --- source1 = (-3, 0) source2 = (3, 0) # --- Animasyon Ayarlar\u0131 --- fig, ax = plt.subplots(figsize=(6,6)) heatmap = ax.imshow(np.zeros((size, size)), cmap='coolwarm', vmin=-1, vmax=1, extent=(-10,10,-10,10)) ax.set_title(\"Two Source Interference Pattern\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") # --- Frame G\u00fcncelleme --- def update(t): r1 = np.sqrt((X - source1[0])**2 + (Y - source1[1])**2) r2 = np.sqrt((X - source2[0])**2 + (Y - source2[1])**2) wave1 = np.sin(k * r1 - omega * t) / (r1 + 1e-6) wave2 = np.sin(k * r2 - omega * t) / (r2 + 1e-6) Z = wave1 + wave2 heatmap.set_data(Z) return [heatmap] ani = FuncAnimation(fig, update, frames=np.linspace(0, 2*np.pi, 60), interval=100) # --- Colab i\u00e7in animasyonu g\u00f6ster --- HTML(ani.to_jshtml()) Visit My Collab import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from mpl_toolkits.mplot3d import Axes3D # --- Grid Setup --- size = 100 # smaller size for faster rendering x = np.linspace(-10, 10, size) y = np.linspace(-10, 10, size) X, Y = np.meshgrid(x, y) # --- Wave Function --- def wave_source(X, Y, x0, y0, t, wavelength=1, speed=1): r = np.sqrt((X - x0)**2 + (Y - y0)**2) k = 2 * np.pi / wavelength omega = k * speed return np.sin(k * r - omega * t) / (r + 1e-6) # --- Source Patterns --- def get_sources(pattern): if pattern == \"one\": return [(0, 0)] elif pattern == \"two\": return [(-3, 0), (3, 0)] elif pattern == \"triangle\": R = 4 angles = np.linspace(0, 2*np.pi, 4)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] elif pattern == \"pentagon\": R = 5 angles = np.linspace(0, 2*np.pi, 6)[:-1] return [(R * np.cos(a), R * np.sin(a)) for a in angles] patterns = [\"one\", \"two\", \"triangle\", \"pentagon\"] # --- Plot Setup --- fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') Z = np.zeros_like(X) surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') title = ax.set_title(\"\") # --- Frame Update Function --- def update(frame): pattern = patterns[(frame // 20) % len(patterns)] t = frame % 20 sources = get_sources(pattern) Z = sum(wave_source(X, Y, sx, sy, t) for sx, sy in sources) ax.clear() # careful: only light clearing surf = ax.plot_surface(X, Y, Z, cmap='RdBu', vmin=-1, vmax=1, linewidth=0, antialiased=True) ax.set_zlim(-1, 1) ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') ax.set_title(f\"Wave Interference: {pattern.capitalize()} ({len(sources)} source{'s' if len(sources) > 1 else ''})\") return surf, # --- Create Animation --- ani = animation.FuncAnimation(fig, update, frames=80, interval=100, blit=False) # --- Save Animation --- ani.save('/content/wave_interference_3d.gif', writer='pillow') plt.close() print(\"\u2705 3D GIF saved as /content/wave_interference_3d.gif\")","title":"\ud83e\uddea Python Simulation Code (Snippet)"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualizations","text":"","title":"\ud83d\udcca Visualizations"},{"location":"1%20Physics/3%20Waves/Problem_1/#one-source-radial-symmetry","text":"Circular ripples expanding outward from the center. No interference is observed since there is only one wavefront . The wave pattern is described by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cdot \\cos(k r - \\omega t + \\phi) \\] Where: \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the radial distance from the source. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number. \\(\\omega = 2\\pi f\\) is the angular frequency.","title":"\u2705 One Source \u2014 Radial Symmetry"},{"location":"1%20Physics/3%20Waves/Problem_1/#two-sources-classic-interference","text":"Alternating constructive and destructive interference zones appear. Central regions exhibit lines of maxima and minima , depending on the relative phase and path difference. The total displacement is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\eta_1(x, y, t) + \\eta_2(x, y, t) \\] Constructive interference occurs when: \\[ \\Delta r = n \\lambda, \\quad n \\in \\mathbb{Z} \\] Destructive interference occurs when: \\[ \\Delta r = \\left(n + \\frac{1}{2}\\right)\\lambda \\]","title":"\u2705 Two Sources \u2014 Classic Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#triangle-or-pentagon-configuration","text":"Multiple coherent sources create complex and symmetric interference patterns . Patterns form an intricate lattice due to overlapping wavefronts. High symmetry and periodicity in amplification (constructive interference) and cancellation (destructive interference) regions. The total displacement from \\(N\\) sources: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where each \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i^{\\text{th}}\\) source. \ud83d\udccc These visualizations help reinforce key wave phenomena including superposition, phase difference, and spatial symmetry.","title":"\u2705 Triangle or Pentagon Configuration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \u26a1 Electromagnetism \u2013 Problem 1: Simulating the Effects of the Lorentz Force \ud83c\udfaf Motivation The Lorentz force governs the motion of charged particles in electromagnetic fields and is described by the equation: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: \\(q\\) : charge of the particle \\(\\vec{E}\\) : electric field \\(\\vec{B}\\) : magnetic field \\(\\vec{v}\\) : velocity of the particle This principle is foundational in: Plasma physics Cyclotrons and synchrotrons Mass spectrometry Astrophysical plasmas \ud83e\uddea Task Overview 1\ufe0f\u20e3 Applications of the Lorentz Force Particle Accelerators : Magnetic fields guide charged particles in circular paths. Mass Spectrometers : Charged ions are deflected by \\(\\vec{B}\\) ; trajectory radius reveals mass-to-charge ratio. Magnetic Confinement : In tokamaks, \\(\\vec{B}\\) confines hot plasma, minimizing loss. 2\ufe0f\u20e3 Simulating Particle Motion We numerically solve Newton's second law with the Lorentz force: \\[ m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Motion types: Uniform \\(\\vec{B}\\) only : Circular or helical motion Uniform \\(\\vec{E}\\) and \\(\\vec{B}\\) : Spiral or drift motion Crossed \\(\\vec{E} \\perp \\vec{B}\\) : \\(E \\times B\\) drift behavior 3\ufe0f\u20e3 Parameter Exploration We allow variations in: Field strengths: \\(\\vec{E}, \\vec{B}\\) Initial velocity: \\(\\vec{v}_0\\) Particle properties: \\(q, m\\) Phenomena to observe: Larmor radius: \\(r_L = \\frac{mv_\\perp}{qB}\\) Drift velocity: \\(\\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) 4\ufe0f\u20e3 Visualization 2D and 3D trajectory plots Visual cues for Larmor orbit and drift Color-coded time or velocity representations import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] \u2014 increased to prevent blow-up dt = 0.001 # smaller time step for better stability steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] # First half-step velocity update (leapfrog) a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): # Full step position update r_next = r[-1] + v_half * dt r.append(r_next) # Compute acceleration at new position (based on velocity) a = lorentz_force(v_half, E, B) / m # Full step velocity update v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) # Store full-step velocity for record return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_spiral = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_spiral, E, B, r0) # 3D Plot of the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show() \ud83d\udd0c Circuits \u2013 Problem: Simplifying a Resistor Network \ud83c\udfaf Scenario Given a resistor network between two points (START and END), simplify the circuit using: Series and parallel combinations Delta-Y and Y-Delta transformations Visual animations (step-by-step or GIF) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.01 # time step steps = 1000 # number of steps # Lorentz force def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog integration def simulate_drift(v0, E, B, r0=np.array([0.0, 0.0, 0.0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r) # Crossed fields E = np.array([0, 1.0, 0]) # Electric field in +y direction B = np.array([0, 0, 1.0]) # Magnetic field in +z direction v0 = np.array([0.0, 0.0, 0.0]) # Initial velocity = 0 r0 = np.array([0.0, 0.0, 0.0]) # Start at origin # Run simulation positions = simulate_drift(v0, E, B, r0) # 3D plot of drift motion fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"3D Drift Motion in Crossed E and B Fields\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") ax.grid(True) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge [C] m = 1.0 # Mass [kg] dt = 0.01 # Time step steps = 1000 # Lorentz force def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog integration def simulate_circular_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt r.append(r_next) return np.array(r) # Initial conditions for circular motion B = np.array([0, 0, 1.0]) # Magnetic field along z E = np.array([0, 0, 0]) # No electric field v0 = np.array([1.0, 0.0, 0.0]) # Velocity perpendicular to B r0 = np.array([0.0, -1.0, 0.0]) # Start off-center for nicer plot # Run simulation positions = simulate_circular_motion(v0, E, B, r0) # 3D plot fig = plt.figure(figsize=(7, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], lw=2) ax.set_title(\"Circular Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") ax.set_box_aspect([1, 1, 0.3]) # Flatten z-axis plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Time array t = np.linspace(0, 20, 500) # E x B drift trajectory (example parametric form) x = t y = -10 * np.cos(t) # circular motion in y z = 0.05 * np.sin(t) # slight oscillation in z # Plotting fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title('E \u00d7 B Drift of Charged Particle') plt.show() \ud83e\uddee Equivalent Resistance Formulas \ud83d\udd0c Resistor Combinations Series combination : \\(R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n\\) Parallel combination : \\(\\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n}\\) Delta to Y (symmetric case) : \\(R_Y = \\frac{R_\\Delta}{3}\\) \ud83d\udce6 Deliverables A visual explanation of charged particle trajectories under various \\(\\vec{E}\\) and \\(\\vec{B}\\) fields Labeled illustrations of how resistor networks reduce to simpler equivalents Mathematical derivations with clear parameter definitions Connections to real-world systems like cyclotrons, mass spectrometers, and power grids \u2728 This simulation-based approach enhances intuition for electromagnetic forces and circuit analysis.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"\u26a1 Electromagnetism \u2013 Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs the motion of charged particles in electromagnetic fields and is described by the equation: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: \\(q\\) : charge of the particle \\(\\vec{E}\\) : electric field \\(\\vec{B}\\) : magnetic field \\(\\vec{v}\\) : velocity of the particle This principle is foundational in: Plasma physics Cyclotrons and synchrotrons Mass spectrometry Astrophysical plasmas","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task-overview","text":"","title":"\ud83e\uddea Task Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-applications-of-the-lorentz-force","text":"Particle Accelerators : Magnetic fields guide charged particles in circular paths. Mass Spectrometers : Charged ions are deflected by \\(\\vec{B}\\) ; trajectory radius reveals mass-to-charge ratio. Magnetic Confinement : In tokamaks, \\(\\vec{B}\\) confines hot plasma, minimizing loss.","title":"1\ufe0f\u20e3 Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We numerically solve Newton's second law with the Lorentz force: \\[ m\\frac{d\\vec{v}}{dt} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Motion types: Uniform \\(\\vec{B}\\) only : Circular or helical motion Uniform \\(\\vec{E}\\) and \\(\\vec{B}\\) : Spiral or drift motion Crossed \\(\\vec{E} \\perp \\vec{B}\\) : \\(E \\times B\\) drift behavior","title":"2\ufe0f\u20e3 Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"We allow variations in: Field strengths: \\(\\vec{E}, \\vec{B}\\) Initial velocity: \\(\\vec{v}_0\\) Particle properties: \\(q, m\\) Phenomena to observe: Larmor radius: \\(r_L = \\frac{mv_\\perp}{qB}\\) Drift velocity: \\(\\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\)","title":"3\ufe0f\u20e3 Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"2D and 3D trajectory plots Visual cues for Larmor orbit and drift Color-coded time or velocity representations import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] \u2014 increased to prevent blow-up dt = 0.001 # smaller time step for better stability steps = 20000 # number of steps # Lorentz force equation def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog (Velocity-Verlet) integration def simulate_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] v = [v0] # First half-step velocity update (leapfrog) a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): # Full step position update r_next = r[-1] + v_half * dt r.append(r_next) # Compute acceleration at new position (based on velocity) a = lorentz_force(v_half, E, B) / m # Full step velocity update v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) # Store full-step velocity for record return np.array(r), np.array(v) # Fields and initial conditions B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis E = np.array([0, 0, 0]) # No electric field v0_spiral = np.array([1.0, 0.0, 0.5]) # Initial velocity with z-component r0 = np.array([0.0, 0.0, 0.0]) # Starting at origin # Run simulation positions, velocities = simulate_motion(v0_spiral, E, B, r0) # 3D Plot of the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"Stable Spiral Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") plt.tight_layout() plt.show()","title":"4\ufe0f\u20e3 Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#circuits-problem-simplifying-a-resistor-network","text":"","title":"\ud83d\udd0c Circuits \u2013 Problem: Simplifying a Resistor Network"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenario","text":"Given a resistor network between two points (START and END), simplify the circuit using: Series and parallel combinations Delta-Y and Y-Delta transformations Visual animations (step-by-step or GIF) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge [C] m = 1.0 # mass [kg] dt = 0.01 # time step steps = 1000 # number of steps # Lorentz force def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog integration def simulate_drift(v0, E, B, r0=np.array([0.0, 0.0, 0.0])): r = [r0] v = [v0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt r.append(r_next) a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt v.append(v_half - 0.5 * a * dt) return np.array(r) # Crossed fields E = np.array([0, 1.0, 0]) # Electric field in +y direction B = np.array([0, 0, 1.0]) # Magnetic field in +z direction v0 = np.array([0.0, 0.0, 0.0]) # Initial velocity = 0 r0 = np.array([0.0, 0.0, 0.0]) # Start at origin # Run simulation positions = simulate_drift(v0, E, B, r0) # 3D plot of drift motion fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2]) ax.set_title(\"3D Drift Motion in Crossed E and B Fields\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") ax.grid(True) plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge [C] m = 1.0 # Mass [kg] dt = 0.01 # Time step steps = 1000 # Lorentz force def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Leapfrog integration def simulate_circular_motion(v0, E, B, r0=np.array([0, 0, 0])): r = [r0] a = lorentz_force(v0, E, B) / m v_half = v0 + 0.5 * a * dt for _ in range(steps): r_next = r[-1] + v_half * dt a = lorentz_force(v_half, E, B) / m v_half = v_half + a * dt r.append(r_next) return np.array(r) # Initial conditions for circular motion B = np.array([0, 0, 1.0]) # Magnetic field along z E = np.array([0, 0, 0]) # No electric field v0 = np.array([1.0, 0.0, 0.0]) # Velocity perpendicular to B r0 = np.array([0.0, -1.0, 0.0]) # Start off-center for nicer plot # Run simulation positions = simulate_circular_motion(v0, E, B, r0) # 3D plot fig = plt.figure(figsize=(7, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(positions[:, 0], positions[:, 1], positions[:, 2], lw=2) ax.set_title(\"Circular Trajectory in Magnetic Field\") ax.set_xlabel(\"x\") ax.set_ylabel(\"y\") ax.set_zlabel(\"z\") ax.set_box_aspect([1, 1, 0.3]) # Flatten z-axis plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Time array t = np.linspace(0, 20, 500) # E x B drift trajectory (example parametric form) x = t y = -10 * np.cos(t) # circular motion in y z = 0.05 * np.sin(t) # slight oscillation in z # Plotting fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z') ax.set_title('E \u00d7 B Drift of Charged Particle') plt.show()","title":"\ud83c\udfaf Scenario"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#equivalent-resistance-formulas","text":"","title":"\ud83e\uddee Equivalent Resistance Formulas"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#resistor-combinations","text":"Series combination : \\(R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n\\) Parallel combination : \\(\\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n}\\) Delta to Y (symmetric case) : \\(R_Y = \\frac{R_\\Delta}{3}\\)","title":"\ud83d\udd0c Resistor Combinations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"A visual explanation of charged particle trajectories under various \\(\\vec{E}\\) and \\(\\vec{B}\\) fields Labeled illustrations of how resistor networks reduce to simpler equivalents Mathematical derivations with clear parameter definitions Connections to real-world systems like cyclotrons, mass spectrometers, and power grids \u2728 This simulation-based approach enhances intuition for electromagnetic forces and circuit analysis.","title":"\ud83d\udce6 Deliverables"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \u26a1 Circuits Problem 1: Equivalent Resistance Using Graph Theory \ud83c\udfaf Problem Statement We are given a complex electrical circuit represented as a graph, where multiple resistors span between two designated nodes: START and END . This circuit may contain arbitrarily nested series and parallel resistor configurations. Goal : Simplify the circuit step by step and compute the total equivalent resistance \\(R_{\\text{eq}}\\) between the START and END nodes. \ud83e\udde0 Conceptual Overview Graph Representation of a Circuit: Nodes : represent electrical junctions. Edges : represent resistors. Weights on Edges : resistance values in ohms ( \\(\\Omega\\) ). By reducing the graph iteratively, we aim to collapse all intermediate connections and leave a single resistor between START and END with resistance \\(R_{\\text{eq}}\\) . \ud83d\udd04 Algorithm Description The circuit is simplified using an iterative algorithm based on identifying series and parallel resistor combinations. \ud83d\udd39 Step 1: Detect Series Connections A node with degree 2 (connected to exactly two other nodes) and not being START or END is a candidate for a series reduction. The two resistors connected to this node are in series: \\( \\(R_{\\text{eq}} = R_1 + R_2\\) \\) The node is removed, and the two edges are replaced by a single edge with the equivalent resistance. \ud83d\udd39 Step 2: Detect Parallel Connections If there are multiple edges between the same pair of nodes , these edges represent resistors in parallel. The equivalent resistance is calculated as: \\( \\(R_{\\text{eq}} = \\left( \\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1}\\) \\) These parallel edges are removed and replaced by a single edge with the equivalent resistance. \ud83d\udd01 Step 3: Repeat Until Simplified The process is repeated: Detect and reduce series connections. Detect and reduce parallel connections. Continue until only a single edge remains between START and END. import networkx as nx import matplotlib.pyplot as plt def draw_graph(G, step_title): pos = nx.spring_layout(G, seed=42) plt.figure(figsize=(6, 4)) edge_labels = {} for u, v, data in G.edges(data=True): label = f\"{data['resistance']}\u03a9\" if G.number_of_edges(u, v) > 1: label = ', '.join(f\"{d['resistance']}\u03a9\" for d in G.get_edge_data(u, v).values()) edge_labels[(u, v)] = label nx.draw( G, pos, with_labels=True, node_color='tomato', node_size=800, edge_color='darkgreen', width=2, font_weight='bold', font_color='black' ) nx.draw_networkx_edge_labels( G, pos, edge_labels=edge_labels, font_color='navy', font_size=9 ) plt.title(step_title) plt.axis('off') plt.show() def combine_series(G): changed = True while changed: changed = False for node in list(G.nodes): if G.degree(node) == 2 and node not in (\"B+\", \"B-\"): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors edge1 = next(iter(G.get_edge_data(u, node).values())) edge2 = next(iter(G.get_edge_data(node, v).values())) R_new = edge1['resistance'] + edge2['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=R_new) changed = True draw_graph(G, f\"{u} - {v} (series): {R_new}\u03a9\") break def combine_parallel(G): to_process = list(G.edges(keys=True)) seen = set() for u, v, k in to_process: if (u, v) in seen or (v, u) in seen: continue if G.number_of_edges(u, v) > 1: resistances = [d['resistance'] for d in G.get_edge_data(u, v).values()] R_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v, key) for key in G.get_edge_data(u, v).keys()]) G.add_edge(u, v, resistance=R_parallel) draw_graph(G, f\"{u} - {v} (parallel): {R_parallel:.2f}\u03a9\") seen.add((u, v)) def reduce_graph(G): draw_graph(G, \"Initial Graph\") while True: nodes_before = len(G.nodes) combine_series(G) combine_parallel(G) if len(G.nodes) == nodes_before: break return G def get_equivalent_resistance(G, source, target): if G.has_edge(source, target): return next(iter(G.get_edge_data(source, target).values()))['resistance'] else: return None def example_case_1(): G = nx.MultiGraph() G.add_nodes_from([\"B+\", \"B-\", \"A\", \"B\", \"C\"]) G.add_edge(\"B+\", \"A\", resistance=2) # R2 G.add_edge(\"A\", \"B\", resistance=3) # R3 G.add_edge(\"B+\", \"B\", resistance=5) # R1 G.add_edge(\"B\", \"C\", resistance=4) # R4 G.add_edge(\"C\", \"B-\", resistance=6) # R5 reduce_graph(G) Req = get_equivalent_resistance(G, \"B+\", \"B-\") print(f\"Equivalent Resistance (Case 1): {Req:.2f} Ohms\") example_case_1() Equivalent Resistance (Case 1): 12.50 Ohms import networkx as nx import matplotlib.pyplot as plt # Koordinatlar pos_case2 = { \"B+\": (0, 1), \"A\": (1, 1), \"X1\": (2, 2), \"X2\": (3, 2), \"Y1\": (2, 0), \"Y2\": (3, 0), \"B\": (4, 1), \"B-\": (5, 1) } def draw_case2(G, title): plt.figure(figsize=(8, 4)) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw( G, pos=pos_case2, with_labels=True, node_size=800, node_color='orange', edge_color='teal', font_weight='bold', font_color='black', width=2 ) nx.draw_networkx_edge_labels( G, pos=pos_case2, edge_labels=edge_labels, font_color='darkred' ) plt.title(title, color='navy') plt.axis('off') plt.show() def combine_series_case2(G): changed = True while changed: changed = False for node in list(G.nodes): if node not in (\"B+\", \"B-\") and G.degree(node) == 2: u, v = list(G.neighbors(node)) r1 = G.get_edge_data(u, node)[0]['resistance'] r2 = G.get_edge_data(node, v)[0]['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=r1 + r2) draw_case2(G, f\"Series combined: {u}-{v} = {r1}+{r2} \u03a9\") changed = True break def combine_parallel_case2(G): for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: resistances = [edata['resistance'] for k, edata in G[u][v].items()] R_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v, k) for k in G[u][v]]) G.add_edge(u, v, resistance=R_parallel) draw_case2(G, f\"Parallel combined: {u}-{v} = {R_parallel:.2f} \u03a9\") def reduce_graph_case2(G): draw_case2(G, \"Initial Circuit (Case 2)\") while True: before = len(G.edges) combine_series_case2(G) combine_parallel_case2(G) if len(G.edges) == before: break def get_equivalent_resistance(G, source, target): return list(G.get_edge_data(source, target).values())[0]['resistance'] def example_case_2(): G = nx.MultiGraph() G.add_nodes_from([\"B+\", \"A\", \"X1\", \"X2\", \"Y1\", \"Y2\", \"B\", \"B-\"]) G.add_edge(\"A\", \"X1\", resistance=2) # R2 G.add_edge(\"X1\", \"X2\", resistance=4) # R4 G.add_edge(\"X2\", \"B\", resistance=0) # ba\u011f G.add_edge(\"A\", \"Y1\", resistance=3) # R3 G.add_edge(\"Y1\", \"Y2\", resistance=6) # R5 G.add_edge(\"Y2\", \"B\", resistance=0) # ba\u011f G.add_edge(\"B+\", \"A\", resistance=1) # R1 G.add_edge(\"B\", \"B-\", resistance=2) # R6 reduce_graph_case2(G) Req = get_equivalent_resistance(G, \"B+\", \"B-\") print(f\"Equivalent Resistance (Case 2): {Req:.2f} \u03a9\") example_case_2() Equivalent Resistance (Case 2): 6.60 \u03a9 import matplotlib.pyplot as plt import networkx as nx def draw_parallel_and_series(): fig, axs = plt.subplots(2, 2, figsize=(14, 10)) fig.suptitle(\"Building Blocks: Parallel and Series Configuration\", fontsize=16) # --- PARALLEL CONFIGURATION --- # Before G1 = nx.DiGraph() G1.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"p1\"), (\"o1\", \"p2\"), (\"p1\", \"o3\"), (\"p2\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"D4\")]) pos1 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"p1\": (2, 2), \"p2\": (2, 0), \"o3\": (3, 1), \"D1\": (4, 2), \"D4\": (4, 0) } nx.draw(G1, pos1, ax=axs[0, 0], with_labels=True, node_color='skyblue', edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G1, pos1, ax=axs[0, 0], edge_labels={ (\"o1\", \"p1\"): \"R1\", (\"o1\", \"p2\"): \"R2\" }, font_color='navy') axs[0, 0].set_title(\"Before (Parallel)\") axs[0, 0].axis('off') # After G2 = nx.DiGraph() G2.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"Dm\")]) pos2 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"o3\": (2, 1), \"D1\": (3, 2), \"Dm\": (3, 0) } nx.draw(G2, pos2, ax=axs[0, 1], with_labels=True, node_color='mediumorchid', edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G2, pos2, ax=axs[0, 1], edge_labels={ (\"o1\", \"o3\"): \"R12\" }, font_color='navy') axs[0, 1].set_title(\"After (1/R1 + 1/R2 = 1/R12)\") axs[0, 1].axis('off') # --- SERIES CONFIGURATION --- # Before G3 = nx.DiGraph() G3.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"o2\"), (\"o2\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"D4\")]) pos3 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"o2\": (2, 1), \"o3\": (3, 1), \"D1\": (4, 2), \"D4\": (4, 0) } node_colors_series = ['skyblue'] * 7 node_colors_series[3] = 'orchid' # o2 nx.draw(G3, pos3, ax=axs[1, 0], with_labels=True, node_color=node_colors_series, edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G3, pos3, ax=axs[1, 0], edge_labels={ (\"o1\", \"o2\"): \"R1\", (\"o2\", \"o3\"): \"R2\" }, font_color='navy') axs[1, 0].set_title(\"Before (Series)\") axs[1, 0].axis('off') # After G4 = nx.DiGraph() G4.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"Dm\")]) pos4 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"o3\": (2, 1), \"D1\": (3, 2), \"Dm\": (3, 0) } nx.draw(G4, pos4, ax=axs[1, 1], with_labels=True, node_color='skyblue', edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G4, pos4, ax=axs[1, 1], edge_labels={ (\"o1\", \"o3\"): \"R12\" }, font_color='navy') axs[1, 1].set_title(\"After (R12 = R1 + R2)\") axs[1, 1].axis('off') plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() draw_parallel_and_series() \ud83d\udd04 Handling Nested Combinations This algorithm is recursive or iterative in nature: - Each iteration simplifies the current layer of the graph. - As the graph is reduced, deeper layers (nested series/parallel combinations) become exposed and simplified in subsequent steps. - This approach handles arbitrary complexity through repeated simplification passes. \ud83e\uddea Example Cases Example 1: Simple Series START --[ \\(R_1 = 2\\Omega\\) ]-- A --[ \\(R_2 = 3\\Omega\\) ]-- END Series reduction: \\( \\(R_{\\text{eq}} = R_1 + R_2 = 5\\Omega\\) \\) Example 2: Simple Parallel START --[ \\(R_1 = 6\\Omega\\) ]-- END START --[ \\(R_2 = 3\\Omega\\) ]-- END Parallel reduction: \\( \\(R_{\\text{eq}} = \\left( \\frac{1}{6} + \\frac{1}{3} \\right)^{-1} = 2\\Omega\\) \\) Example 3: Nested Series and Parallel START --[ \\(R_1 = 2\\Omega\\) ]-- A --[ \\(R_2 = 4\\Omega\\) ]-- B --[ \\(R_3 = 2\\Omega\\) ]-- END Also, A and B are connected via \\(R_4 = 4\\Omega\\) (in parallel with \\(R_2\\) ) First reduce the parallel connection between A and B: \\( \\(R_{AB} = \\left( \\frac{1}{4} + \\frac{1}{4} \\right)^{-1} = 2\\Omega\\) \\) Now, combine in series: \\( \\(R_{\\text{eq}} = R_1 + R_{AB} + R_3 = 2 + 2 + 2 = 6\\Omega\\) \\) \ud83d\uddbc\ufe0f Visualization as a GIF or Sequence To create an animated or step-by-step visualization: Frame 1 : Full resistor network as a graph. Frame 2 : Highlight and collapse a series connection. Frame 3 : Highlight and collapse a parallel connection. Repeat : Continue until only a single resistor remains between START and END. Final Frame : Display \\(R_{\\text{eq}}\\) This sequence can be turned into a visual animation using a graph visualization library or diagramming tool. \ud83d\udcc8 Efficiency and Extensions Time Complexity (Conceptual): Best case : \\(O(n)\\) (linear chain) Average/Worst case : \\(O(n^2)\\) or more, depending on connectivity and cycles Possible Improvements: Detecting patterns using depth-first search (DFS) Using union-find data structures to track connected components Implementing advanced transformations (e.g., Y-\u0394 transforms) \u2705 Conclusion By modeling a circuit as a graph and applying a reduction algorithm that detects series and parallel resistors, we can efficiently compute equivalent resistance\u2014even in highly complex networks. This approach demonstrates the powerful synergy between electrical engineering and graph theory, enabling automation, scalability, and deeper insights into circuit behavior.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits-problem-1-equivalent-resistance-using-graph-theory","text":"","title":"\u26a1 Circuits Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-statement","text":"We are given a complex electrical circuit represented as a graph, where multiple resistors span between two designated nodes: START and END . This circuit may contain arbitrarily nested series and parallel resistor configurations. Goal : Simplify the circuit step by step and compute the total equivalent resistance \\(R_{\\text{eq}}\\) between the START and END nodes.","title":"\ud83c\udfaf Problem Statement"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conceptual-overview","text":"","title":"\ud83e\udde0 Conceptual Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation-of-a-circuit","text":"Nodes : represent electrical junctions. Edges : represent resistors. Weights on Edges : resistance values in ohms ( \\(\\Omega\\) ). By reducing the graph iteratively, we aim to collapse all intermediate connections and leave a single resistor between START and END with resistance \\(R_{\\text{eq}}\\) .","title":"Graph Representation of a Circuit:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"The circuit is simplified using an iterative algorithm based on identifying series and parallel resistor combinations.","title":"\ud83d\udd04 Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-detect-series-connections","text":"A node with degree 2 (connected to exactly two other nodes) and not being START or END is a candidate for a series reduction. The two resistors connected to this node are in series: \\( \\(R_{\\text{eq}} = R_1 + R_2\\) \\) The node is removed, and the two edges are replaced by a single edge with the equivalent resistance.","title":"\ud83d\udd39 Step 1: Detect Series Connections"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-detect-parallel-connections","text":"If there are multiple edges between the same pair of nodes , these edges represent resistors in parallel. The equivalent resistance is calculated as: \\( \\(R_{\\text{eq}} = \\left( \\sum_{i=1}^{n} \\frac{1}{R_i} \\right)^{-1}\\) \\) These parallel edges are removed and replaced by a single edge with the equivalent resistance.","title":"\ud83d\udd39 Step 2: Detect Parallel Connections"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-repeat-until-simplified","text":"The process is repeated: Detect and reduce series connections. Detect and reduce parallel connections. Continue until only a single edge remains between START and END. import networkx as nx import matplotlib.pyplot as plt def draw_graph(G, step_title): pos = nx.spring_layout(G, seed=42) plt.figure(figsize=(6, 4)) edge_labels = {} for u, v, data in G.edges(data=True): label = f\"{data['resistance']}\u03a9\" if G.number_of_edges(u, v) > 1: label = ', '.join(f\"{d['resistance']}\u03a9\" for d in G.get_edge_data(u, v).values()) edge_labels[(u, v)] = label nx.draw( G, pos, with_labels=True, node_color='tomato', node_size=800, edge_color='darkgreen', width=2, font_weight='bold', font_color='black' ) nx.draw_networkx_edge_labels( G, pos, edge_labels=edge_labels, font_color='navy', font_size=9 ) plt.title(step_title) plt.axis('off') plt.show() def combine_series(G): changed = True while changed: changed = False for node in list(G.nodes): if G.degree(node) == 2 and node not in (\"B+\", \"B-\"): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors edge1 = next(iter(G.get_edge_data(u, node).values())) edge2 = next(iter(G.get_edge_data(node, v).values())) R_new = edge1['resistance'] + edge2['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=R_new) changed = True draw_graph(G, f\"{u} - {v} (series): {R_new}\u03a9\") break def combine_parallel(G): to_process = list(G.edges(keys=True)) seen = set() for u, v, k in to_process: if (u, v) in seen or (v, u) in seen: continue if G.number_of_edges(u, v) > 1: resistances = [d['resistance'] for d in G.get_edge_data(u, v).values()] R_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v, key) for key in G.get_edge_data(u, v).keys()]) G.add_edge(u, v, resistance=R_parallel) draw_graph(G, f\"{u} - {v} (parallel): {R_parallel:.2f}\u03a9\") seen.add((u, v)) def reduce_graph(G): draw_graph(G, \"Initial Graph\") while True: nodes_before = len(G.nodes) combine_series(G) combine_parallel(G) if len(G.nodes) == nodes_before: break return G def get_equivalent_resistance(G, source, target): if G.has_edge(source, target): return next(iter(G.get_edge_data(source, target).values()))['resistance'] else: return None def example_case_1(): G = nx.MultiGraph() G.add_nodes_from([\"B+\", \"B-\", \"A\", \"B\", \"C\"]) G.add_edge(\"B+\", \"A\", resistance=2) # R2 G.add_edge(\"A\", \"B\", resistance=3) # R3 G.add_edge(\"B+\", \"B\", resistance=5) # R1 G.add_edge(\"B\", \"C\", resistance=4) # R4 G.add_edge(\"C\", \"B-\", resistance=6) # R5 reduce_graph(G) Req = get_equivalent_resistance(G, \"B+\", \"B-\") print(f\"Equivalent Resistance (Case 1): {Req:.2f} Ohms\") example_case_1() Equivalent Resistance (Case 1): 12.50 Ohms import networkx as nx import matplotlib.pyplot as plt # Koordinatlar pos_case2 = { \"B+\": (0, 1), \"A\": (1, 1), \"X1\": (2, 2), \"X2\": (3, 2), \"Y1\": (2, 0), \"Y2\": (3, 0), \"B\": (4, 1), \"B-\": (5, 1) } def draw_case2(G, title): plt.figure(figsize=(8, 4)) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw( G, pos=pos_case2, with_labels=True, node_size=800, node_color='orange', edge_color='teal', font_weight='bold', font_color='black', width=2 ) nx.draw_networkx_edge_labels( G, pos=pos_case2, edge_labels=edge_labels, font_color='darkred' ) plt.title(title, color='navy') plt.axis('off') plt.show() def combine_series_case2(G): changed = True while changed: changed = False for node in list(G.nodes): if node not in (\"B+\", \"B-\") and G.degree(node) == 2: u, v = list(G.neighbors(node)) r1 = G.get_edge_data(u, node)[0]['resistance'] r2 = G.get_edge_data(node, v)[0]['resistance'] G.remove_node(node) G.add_edge(u, v, resistance=r1 + r2) draw_case2(G, f\"Series combined: {u}-{v} = {r1}+{r2} \u03a9\") changed = True break def combine_parallel_case2(G): for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: resistances = [edata['resistance'] for k, edata in G[u][v].items()] R_parallel = 1 / sum(1/r for r in resistances) G.remove_edges_from([(u, v, k) for k in G[u][v]]) G.add_edge(u, v, resistance=R_parallel) draw_case2(G, f\"Parallel combined: {u}-{v} = {R_parallel:.2f} \u03a9\") def reduce_graph_case2(G): draw_case2(G, \"Initial Circuit (Case 2)\") while True: before = len(G.edges) combine_series_case2(G) combine_parallel_case2(G) if len(G.edges) == before: break def get_equivalent_resistance(G, source, target): return list(G.get_edge_data(source, target).values())[0]['resistance'] def example_case_2(): G = nx.MultiGraph() G.add_nodes_from([\"B+\", \"A\", \"X1\", \"X2\", \"Y1\", \"Y2\", \"B\", \"B-\"]) G.add_edge(\"A\", \"X1\", resistance=2) # R2 G.add_edge(\"X1\", \"X2\", resistance=4) # R4 G.add_edge(\"X2\", \"B\", resistance=0) # ba\u011f G.add_edge(\"A\", \"Y1\", resistance=3) # R3 G.add_edge(\"Y1\", \"Y2\", resistance=6) # R5 G.add_edge(\"Y2\", \"B\", resistance=0) # ba\u011f G.add_edge(\"B+\", \"A\", resistance=1) # R1 G.add_edge(\"B\", \"B-\", resistance=2) # R6 reduce_graph_case2(G) Req = get_equivalent_resistance(G, \"B+\", \"B-\") print(f\"Equivalent Resistance (Case 2): {Req:.2f} \u03a9\") example_case_2() Equivalent Resistance (Case 2): 6.60 \u03a9 import matplotlib.pyplot as plt import networkx as nx def draw_parallel_and_series(): fig, axs = plt.subplots(2, 2, figsize=(14, 10)) fig.suptitle(\"Building Blocks: Parallel and Series Configuration\", fontsize=16) # --- PARALLEL CONFIGURATION --- # Before G1 = nx.DiGraph() G1.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"p1\"), (\"o1\", \"p2\"), (\"p1\", \"o3\"), (\"p2\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"D4\")]) pos1 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"p1\": (2, 2), \"p2\": (2, 0), \"o3\": (3, 1), \"D1\": (4, 2), \"D4\": (4, 0) } nx.draw(G1, pos1, ax=axs[0, 0], with_labels=True, node_color='skyblue', edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G1, pos1, ax=axs[0, 0], edge_labels={ (\"o1\", \"p1\"): \"R1\", (\"o1\", \"p2\"): \"R2\" }, font_color='navy') axs[0, 0].set_title(\"Before (Parallel)\") axs[0, 0].axis('off') # After G2 = nx.DiGraph() G2.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"Dm\")]) pos2 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"o3\": (2, 1), \"D1\": (3, 2), \"Dm\": (3, 0) } nx.draw(G2, pos2, ax=axs[0, 1], with_labels=True, node_color='mediumorchid', edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G2, pos2, ax=axs[0, 1], edge_labels={ (\"o1\", \"o3\"): \"R12\" }, font_color='navy') axs[0, 1].set_title(\"After (1/R1 + 1/R2 = 1/R12)\") axs[0, 1].axis('off') # --- SERIES CONFIGURATION --- # Before G3 = nx.DiGraph() G3.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"o2\"), (\"o2\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"D4\")]) pos3 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"o2\": (2, 1), \"o3\": (3, 1), \"D1\": (4, 2), \"D4\": (4, 0) } node_colors_series = ['skyblue'] * 7 node_colors_series[3] = 'orchid' # o2 nx.draw(G3, pos3, ax=axs[1, 0], with_labels=True, node_color=node_colors_series, edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G3, pos3, ax=axs[1, 0], edge_labels={ (\"o1\", \"o2\"): \"R1\", (\"o2\", \"o3\"): \"R2\" }, font_color='navy') axs[1, 0].set_title(\"Before (Series)\") axs[1, 0].axis('off') # After G4 = nx.DiGraph() G4.add_edges_from([(\"I1\", \"o1\"), (\"In\", \"o1\"), (\"o1\", \"o3\"), (\"o3\", \"D1\"), (\"o3\", \"Dm\")]) pos4 = { \"I1\": (0, 2), \"In\": (0, 0), \"o1\": (1, 1), \"o3\": (2, 1), \"D1\": (3, 2), \"Dm\": (3, 0) } nx.draw(G4, pos4, ax=axs[1, 1], with_labels=True, node_color='skyblue', edge_color='dimgray', node_size=800) nx.draw_networkx_edge_labels(G4, pos4, ax=axs[1, 1], edge_labels={ (\"o1\", \"o3\"): \"R12\" }, font_color='navy') axs[1, 1].set_title(\"After (R12 = R1 + R2)\") axs[1, 1].axis('off') plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() draw_parallel_and_series()","title":"\ud83d\udd01 Step 3: Repeat Until Simplified"},{"location":"1%20Physics/5%20Circuits/Problem_1/#handling-nested-combinations","text":"This algorithm is recursive or iterative in nature: - Each iteration simplifies the current layer of the graph. - As the graph is reduced, deeper layers (nested series/parallel combinations) become exposed and simplified in subsequent steps. - This approach handles arbitrary complexity through repeated simplification passes.","title":"\ud83d\udd04 Handling Nested Combinations"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-cases","text":"","title":"\ud83e\uddea Example Cases"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series","text":"START --[ \\(R_1 = 2\\Omega\\) ]-- A --[ \\(R_2 = 3\\Omega\\) ]-- END Series reduction: \\( \\(R_{\\text{eq}} = R_1 + R_2 = 5\\Omega\\) \\)","title":"Example 1: Simple Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-simple-parallel","text":"START --[ \\(R_1 = 6\\Omega\\) ]-- END START --[ \\(R_2 = 3\\Omega\\) ]-- END Parallel reduction: \\( \\(R_{\\text{eq}} = \\left( \\frac{1}{6} + \\frac{1}{3} \\right)^{-1} = 2\\Omega\\) \\)","title":"Example 2: Simple Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-series-and-parallel","text":"START --[ \\(R_1 = 2\\Omega\\) ]-- A --[ \\(R_2 = 4\\Omega\\) ]-- B --[ \\(R_3 = 2\\Omega\\) ]-- END Also, A and B are connected via \\(R_4 = 4\\Omega\\) (in parallel with \\(R_2\\) ) First reduce the parallel connection between A and B: \\( \\(R_{AB} = \\left( \\frac{1}{4} + \\frac{1}{4} \\right)^{-1} = 2\\Omega\\) \\) Now, combine in series: \\( \\(R_{\\text{eq}} = R_1 + R_{AB} + R_3 = 2 + 2 + 2 = 6\\Omega\\) \\)","title":"Example 3: Nested Series and Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#visualization-as-a-gif-or-sequence","text":"To create an animated or step-by-step visualization: Frame 1 : Full resistor network as a graph. Frame 2 : Highlight and collapse a series connection. Frame 3 : Highlight and collapse a parallel connection. Repeat : Continue until only a single resistor remains between START and END. Final Frame : Display \\(R_{\\text{eq}}\\) This sequence can be turned into a visual animation using a graph visualization library or diagramming tool.","title":"\ud83d\uddbc\ufe0f Visualization as a GIF or Sequence"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-and-extensions","text":"","title":"\ud83d\udcc8 Efficiency and Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/#time-complexity-conceptual","text":"Best case : \\(O(n)\\) (linear chain) Average/Worst case : \\(O(n^2)\\) or more, depending on connectivity and cycles","title":"Time Complexity (Conceptual):"},{"location":"1%20Physics/5%20Circuits/Problem_1/#possible-improvements","text":"Detecting patterns using depth-first search (DFS) Using union-find data structures to track connected components Implementing advanced transformations (e.g., Y-\u0394 transforms)","title":"Possible Improvements:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"By modeling a circuit as a graph and applying a reduction algorithm that detects series and parallel resistors, we can efficiently compute equivalent resistance\u2014even in highly complex networks. This approach demonstrates the powerful synergy between electrical engineering and graph theory, enabling automation, scalability, and deeper insights into circuit behavior.","title":"\u2705 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Problem 1: Exploring the Central Limit Theorem (CLT) Through Simulations \ud83d\udccc Motivation The Central Limit Theorem (CLT) is a foundational result in probability and statistics. It asserts: Given a population with any distribution that has a finite mean \\(\\mu\\) and finite standard deviation \\(\\sigma\\) , the distribution of the sample mean \\(\\bar{X}\\) will tend to be approximately normal as the sample size \\(n\\) increases. In symbols: \\[ \\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\quad \\text{as } n \\rightarrow \\infty \\] This result enables statisticians to apply inferential techniques even when the underlying population distribution is not normal. \ud83c\udfaf Objectives Simulate samples from various population distributions. Visualize the sample mean distributions. Observe convergence to the normal distribution. Discuss the effect of sample size and population variance. Reflect on real-world implications of CLT. 1. Simulating Sampling Distributions We consider three population types: Uniform distribution : \\(X \\sim \\mathcal{U}(a, b)\\) Exponential distribution : \\(X \\sim \\text{Exp}(\\lambda)\\) Binomial distribution : \\(X \\sim \\text{Binomial}(n, p)\\) Each distribution generates a large population dataset (e.g., 100,000 values) for sampling. 2. Sampling and Visualization We take samples of various sizes: Sample sizes: \\(n = 5, 10, 30, 50\\) For each sample size: Draw 1000 samples from the population Compute the sample mean \\(\\bar{X}\\) Plot the histogram of sample means As \\(n\\) increases: Sample mean distribution becomes smoother Shape becomes increasingly bell-curved (i.e., normal) Extreme skew or kurtosis in the population diminishes 3. Parameter Exploration \ud83d\udd0d Distribution Shape Uniform: Converges quickly to normal due to symmetry Exponential: Starts skewed, but normality emerges with larger \\(n\\) Binomial: Discrete but approximates normal if \\(n\\) is large and \\(p\\) not extreme \ud83d\udd0d Sample Size Impact The variance of the sampling distribution decreases with \\(n\\) The formula for the variance of sample mean: \\[ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} \\] Hence, larger \\(n\\) reduces the spread of the sample mean histogram. 4. Practical Applications Parameter Estimation : Means from samples are used to infer population characteristics Manufacturing : Control charts based on sampling assume normality Finance : Return models use CLT to assume average performance is normally distributed Epidemiology : Average rates (e.g., infection rates) are modeled under CLT assumptions \ud83d\udcda Key Definitions Sample Mean : \\(\\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i\\) Population Mean : \\(\\mu = \\mathbb{E}[X]\\) Sample Variance : \\(s^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\bar{X})^2\\) Sampling Distribution : Distribution of \\(\\bar{X}\\) over many samples Normal Distribution : A symmetric bell-shaped distribution defined by \\(\\mathcal{N}(\\mu, \\sigma^2)\\) \ud83d\udcc8 Visual Summary (to be attached) Histograms of sample means for each population and \\(n\\) Normal curves overlayed for comparison Convergence clearly visible as \\(n\\) increases \ud83e\udde0 Conclusion CLT holds regardless of population shape, provided sample size is sufficiently large Larger \\(n\\) and smaller \\(\\sigma\\) lead to faster convergence CLT provides the mathematical foundation for many real-world statistical methods ```python import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import gaussian_kde Stil ayar\u0131 sns.set(style=\"whitegrid\") Pop\u00fclasyonlar\u0131n tan\u0131mlanmas\u0131 uniform_population = np.random.uniform(0, 1, 10000) exponential_population = np.random.exponential(1, 10000) binomial_population = np.random.binomial(n=1, p=0.5, size=10000) T\u00fcm pop\u00fclasyonlar\u0131 bir s\u00f6zl\u00fckte tut populations = { 'Uniform': uniform_population, 'Exponential': exponential_population, 'Binomial': binomial_population } Farkl\u0131 \u00f6rneklem b\u00fcy\u00fckl\u00fckleri sample_sizes = [5, 10, 30, 50] T\u00fcm pop\u00fclasyonlar i\u00e7in i\u015flem for name, population in populations.items(): plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes, 1): sample_means = [] for _ in range(1000): sample = np.random.choice(population, size=size) sample_means.append(np.mean(sample)) # Alt grafik olu\u015ftur plt.subplot(2, 2, i) # Histogram sns.histplot(sample_means, bins=30, color=\"orchid\", stat=\"frequency\", kde=False) # KDE (manuel \u00e7izim) kde = gaussian_kde(sample_means) x_vals = np.linspace(min(sample_means), max(sample_means), 200) y_vals = kde(x_vals) * len(sample_means) * (max(sample_means) - min(sample_means)) / 30 plt.plot(x_vals, y_vals, color='darkmagenta', linewidth=2) plt.title(f\"{name} Distribution - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of the Mean - {name}\", fontsize=18) plt.tight_layout() plt.show() ``` \ud83d\udd17 References Wasserman, L. (2004). All of Statistics Khan Academy: Central Limit Theorem Wikipedia: Central Limit Theorem","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-clt-through-simulations","text":"","title":"Problem 1: Exploring the Central Limit Theorem (CLT) Through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a foundational result in probability and statistics. It asserts: Given a population with any distribution that has a finite mean \\(\\mu\\) and finite standard deviation \\(\\sigma\\) , the distribution of the sample mean \\(\\bar{X}\\) will tend to be approximately normal as the sample size \\(n\\) increases. In symbols: \\[ \\bar{X} \\sim \\mathcal{N}\\left(\\mu, \\frac{\\sigma^2}{n}\\right) \\quad \\text{as } n \\rightarrow \\infty \\] This result enables statisticians to apply inferential techniques even when the underlying population distribution is not normal.","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objectives","text":"Simulate samples from various population distributions. Visualize the sample mean distributions. Observe convergence to the normal distribution. Discuss the effect of sample size and population variance. Reflect on real-world implications of CLT.","title":"\ud83c\udfaf Objectives"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"We consider three population types: Uniform distribution : \\(X \\sim \\mathcal{U}(a, b)\\) Exponential distribution : \\(X \\sim \\text{Exp}(\\lambda)\\) Binomial distribution : \\(X \\sim \\text{Binomial}(n, p)\\) Each distribution generates a large population dataset (e.g., 100,000 values) for sampling.","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"We take samples of various sizes: Sample sizes: \\(n = 5, 10, 30, 50\\) For each sample size: Draw 1000 samples from the population Compute the sample mean \\(\\bar{X}\\) Plot the histogram of sample means As \\(n\\) increases: Sample mean distribution becomes smoother Shape becomes increasingly bell-curved (i.e., normal) Extreme skew or kurtosis in the population diminishes","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#distribution-shape","text":"Uniform: Converges quickly to normal due to symmetry Exponential: Starts skewed, but normality emerges with larger \\(n\\) Binomial: Discrete but approximates normal if \\(n\\) is large and \\(p\\) not extreme","title":"\ud83d\udd0d Distribution Shape"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sample-size-impact","text":"The variance of the sampling distribution decreases with \\(n\\) The formula for the variance of sample mean: \\[ \\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n} \\] Hence, larger \\(n\\) reduces the spread of the sample mean histogram.","title":"\ud83d\udd0d Sample Size Impact"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"Parameter Estimation : Means from samples are used to infer population characteristics Manufacturing : Control charts based on sampling assume normality Finance : Return models use CLT to assume average performance is normally distributed Epidemiology : Average rates (e.g., infection rates) are modeled under CLT assumptions","title":"4. Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-definitions","text":"Sample Mean : \\(\\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i\\) Population Mean : \\(\\mu = \\mathbb{E}[X]\\) Sample Variance : \\(s^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\bar{X})^2\\) Sampling Distribution : Distribution of \\(\\bar{X}\\) over many samples Normal Distribution : A symmetric bell-shaped distribution defined by \\(\\mathcal{N}(\\mu, \\sigma^2)\\)","title":"\ud83d\udcda Key Definitions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visual-summary-to-be-attached","text":"Histograms of sample means for each population and \\(n\\) Normal curves overlayed for comparison Convergence clearly visible as \\(n\\) increases","title":"\ud83d\udcc8 Visual Summary (to be attached)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"CLT holds regardless of population shape, provided sample size is sufficiently large Larger \\(n\\) and smaller \\(\\sigma\\) lead to faster convergence CLT provides the mathematical foundation for many real-world statistical methods ```python import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import gaussian_kde","title":"\ud83e\udde0 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#stil-ayar","text":"sns.set(style=\"whitegrid\")","title":"Stil ayar\u0131"},{"location":"1%20Physics/6%20Statistics/Problem_1/#populasyonlarn-tanmlanmas","text":"uniform_population = np.random.uniform(0, 1, 10000) exponential_population = np.random.exponential(1, 10000) binomial_population = np.random.binomial(n=1, p=0.5, size=10000)","title":"Pop\u00fclasyonlar\u0131n tan\u0131mlanmas\u0131"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tum-populasyonlar-bir-sozlukte-tut","text":"populations = { 'Uniform': uniform_population, 'Exponential': exponential_population, 'Binomial': binomial_population }","title":"T\u00fcm pop\u00fclasyonlar\u0131 bir s\u00f6zl\u00fckte tut"},{"location":"1%20Physics/6%20Statistics/Problem_1/#farkl-orneklem-buyuklukleri","text":"sample_sizes = [5, 10, 30, 50]","title":"Farkl\u0131 \u00f6rneklem b\u00fcy\u00fckl\u00fckleri"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tum-populasyonlar-icin-islem","text":"for name, population in populations.items(): plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes, 1): sample_means = [] for _ in range(1000): sample = np.random.choice(population, size=size) sample_means.append(np.mean(sample)) # Alt grafik olu\u015ftur plt.subplot(2, 2, i) # Histogram sns.histplot(sample_means, bins=30, color=\"orchid\", stat=\"frequency\", kde=False) # KDE (manuel \u00e7izim) kde = gaussian_kde(sample_means) x_vals = np.linspace(min(sample_means), max(sample_means), 200) y_vals = kde(x_vals) * len(sample_means) * (max(sample_means) - min(sample_means)) / 30 plt.plot(x_vals, y_vals, color='darkmagenta', linewidth=2) plt.title(f\"{name} Distribution - Sample Size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distribution of the Mean - {name}\", fontsize=18) plt.tight_layout() plt.show() ```","title":"T\u00fcm pop\u00fclasyonlar i\u00e7in i\u015flem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#references","text":"Wasserman, L. (2004). All of Statistics Khan Academy: Central Limit Theorem Wikipedia: Central Limit Theorem","title":"\ud83d\udd17 References"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2: Estimating \\(\\pi\\) Using Monte Carlo Methods \ud83c\udfaf Motivation Monte Carlo simulations harness randomness to approximate values or solve complex problems numerically. A classic example is the estimation of \\(\\pi\\) using geometric probability. These simulations demonstrate fundamental connections between probability, geometry, and numerical computation. We explore two Monte Carlo approaches: Estimating \\(\\pi\\) using random points in a square and a unit circle. Estimating \\(\\pi\\) using Buffon's Needle experiment. Part 1: Estimating \\(\\pi\\) Using a Circle \ud83d\udcd0 1. Theoretical Foundation Consider a unit circle inscribed in a square of side length 2 (from \\([-1, 1]\\) on both axes). The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi (1)^2 = \\pi \\] The area of the square is: \\[ A_{\\text{square}} = (2)^2 = 4 \\] If we randomly distribute points inside the square, the proportion of points that fall inside the circle should be approximately equal to the ratio of the circle's area to the square's area: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Solving for \\(\\pi\\) : \\[ \\pi \\approx 4 \\cdot \\left( \\frac{\\text{Points inside circle}}{\\text{Total points}} \\right) \\] ```python import numpy as np import matplotlib.pyplot as plt Nokta say\u0131s\u0131 n = 10000 Rastgele (x, y) noktalar\u0131 \u00fcret x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n) Dairenin i\u00e7inde olup olmad\u0131\u011f\u0131n\u0131 kontrol et inside = x 2 + y 2 <= 1 Pi tahmini pi_estimate = 4 * np.sum(inside) / n G\u00f6rselle\u015ftirme plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='darkgreen', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='crimson', label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo \u03c0 Estimate ({n} points)\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.grid(True) plt.show() ``` \ud83e\uddea 2. Simulation Steps: - Generate \\(N\\) random \\((x, y)\\) points in \\([-1, 1] \\times [-1, 1]\\) . - Count how many satisfy \\(x^2 + y^2 \\leq 1\\) (inside the circle). - Estimate \\(\\pi\\) using the formula above. \ud83d\udcca 3. Visualization Plot all generated points. Highlight points inside the circle in one color (e.g., green). Points outside in another color (e.g., red). Optionally, draw the boundary of the unit circle. \ud83d\udcc8 4. Analysis Run simulations for increasing \\(N\\) (e.g., \\(100, 1000, 10^4, 10^5\\) ). Record the estimate of \\(\\pi\\) at each \\(N\\) . Plot \\(\\pi\\) estimates vs. \\(N\\) to observe convergence. Discuss computational time and accuracy. Part 2: Estimating \\(\\pi\\) Using Buffon's Needle \ud83d\udcd0 1. Theoretical Foundation Buffon's Needle experiment involves dropping a needle of length \\(l\\) on a plane with parallel lines spaced \\(d\\) units apart. If \\(l \\leq d\\) , the probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2l}{\\pi d} \\] Rearranged to estimate \\(\\pi\\) : \\[ \\pi \\approx \\frac{2l \\cdot N}{d \\cdot C} \\] Where: - \\(N\\) = number of needle drops - \\(C\\) = number of crosses (intersections with a line) ```python import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(num_needles): length = 1.0 # Needle length spacing = 1.0 # Line spacing crosses = 0 x_start = [] y_start = [] x_end = [] y_end = [] cross_flags = [] for _ in range(num_needles): y_center = np.random.uniform(0, spacing / 2) angle = np.random.uniform(0, np.pi / 2) y_proj = (length / 2) * np.sin(angle) if y_proj >= y_center: crosses += 1 cross_flags.append(True) else: cross_flags.append(False) x0 = 0 y0 = y_center x1 = (length / 2) * np.cos(angle) y1 = (length / 2) * np.sin(angle) x_start.append(x0 - x1) y_start.append(y0 - y1) x_end.append(x0 + x1) y_end.append(y0 + y1) if crosses == 0: pi_est = None print(\"No crosses occurred \u2014 try more drops.\") else: pi_est = (2 * num_needles) / crosses # Plotting plt.figure(figsize=(8, 4)) for i in range(num_needles): color = 'green' if cross_flags[i] else 'gray' plt.plot([x_start[i], x_end[i]], [y_start[i], y_end[i]], color=color, alpha=0.5) for y in np.arange(0, spacing * 2, spacing): plt.axhline(y=y, color='black', linewidth=0.5) plt.title(f\"Buffon\u2019s Needle Simulation\\nNeedles: {num_needles}, \u03c0 \u2248 {pi_est:.5f}\" if pi_est else \"No estimate\") plt.axis('equal') plt.grid(True) plt.show() ``` \ud83e\uddea 2. Simulation Steps: - Set needle length \\(l\\) and line spacing \\(d\\) (commonly \\(l = d = 1\\) ). - Drop the needle \\(N\\) times: - Randomly place its center \\(y \\in [0, d/2]\\) - Randomly select angle \\(\\theta \\in [0, \\pi/2]\\) - If \\(y \\leq \\frac{l}{2} \\sin(\\theta)\\) , it's a hit (crossing). - Use above formula to estimate \\(\\pi\\) . \ud83d\udcca 3. Visualization Show parallel lines spaced \\(d\\) units apart. Draw needles as lines across drops. Use different colors for crossing vs non-crossing needles. \ud83d\udcc8 4. Analysis Vary number of drops \\(N\\) : \\(100, 1000, 10000, \\ldots\\) Record number of crossings \\(C\\) and \\(\\pi\\) estimate. Compare with the circle-based method: Which one converges faster? Which one is more stable? Discuss runtime and sensitivity to randomness. \ud83e\uddfe Definitions and Key Concepts Monte Carlo Method : A computational algorithm relying on repeated random sampling to obtain numerical results. Unit Circle : Circle with radius \\(r = 1\\) centered at origin. Buffon's Needle : Classical probability problem estimating \\(\\pi\\) from geometric probabilities. Convergence Rate : How fast an estimate approaches the true value as the number of samples increases. \ud83d\udcc8 Deliverables 1. Markdown Document: Includes all theory, explanations, and observations. 2. Python Simulations: One script for the unit circle method. One script for Buffon\u2019s Needle method. 3. Visual Outputs: Scatter plots of circle simulation. Needle-drop visualizations. \\(\\pi\\) vs number of samples graphs. 4. Comparative Analysis: Table of \\(\\pi\\) estimates vs sample size. Commentary on computational efficiency and accuracy. \ud83d\udd17 References Grinstead, C. M., & Snell, J. L. (1997). Introduction to Probability . Wikipedia: Monte Carlo method Wikipedia: Buffon's needle","title":"Problem 2: Estimating \\(\\pi\\) Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2-estimating-pi-using-monte-carlo-methods","text":"","title":"Problem 2: Estimating \\(\\pi\\) Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations harness randomness to approximate values or solve complex problems numerically. A classic example is the estimation of \\(\\pi\\) using geometric probability. These simulations demonstrate fundamental connections between probability, geometry, and numerical computation. We explore two Monte Carlo approaches: Estimating \\(\\pi\\) using random points in a square and a unit circle. Estimating \\(\\pi\\) using Buffon's Needle experiment.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"Part 1: Estimating \\(\\pi\\) Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"Consider a unit circle inscribed in a square of side length 2 (from \\([-1, 1]\\) on both axes). The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi (1)^2 = \\pi \\] The area of the square is: \\[ A_{\\text{square}} = (2)^2 = 4 \\] If we randomly distribute points inside the square, the proportion of points that fall inside the circle should be approximately equal to the ratio of the circle's area to the square's area: \\[ \\frac{\\text{Points inside circle}}{\\text{Total points}} \\approx \\frac{\\pi}{4} \\] Solving for \\(\\pi\\) : \\[ \\pi \\approx 4 \\cdot \\left( \\frac{\\text{Points inside circle}}{\\text{Total points}} \\right) \\] ```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcd0 1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#nokta-says","text":"n = 10000","title":"Nokta say\u0131s\u0131"},{"location":"1%20Physics/6%20Statistics/Problem_2/#rastgele-x-y-noktalar-uret","text":"x = np.random.uniform(-1, 1, n) y = np.random.uniform(-1, 1, n)","title":"Rastgele (x, y) noktalar\u0131 \u00fcret"},{"location":"1%20Physics/6%20Statistics/Problem_2/#dairenin-icinde-olup-olmadgn-kontrol-et","text":"inside = x 2 + y 2 <= 1","title":"Dairenin i\u00e7inde olup olmad\u0131\u011f\u0131n\u0131 kontrol et"},{"location":"1%20Physics/6%20Statistics/Problem_2/#pi-tahmini","text":"pi_estimate = 4 * np.sum(inside) / n","title":"Pi tahmini"},{"location":"1%20Physics/6%20Statistics/Problem_2/#gorsellestirme","text":"plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], s=1, color='darkgreen', label='Inside Circle') plt.scatter(x[~inside], y[~inside], s=1, color='crimson', label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f\"Monte Carlo \u03c0 Estimate ({n} points)\\n\u03c0 \u2248 {pi_estimate:.6f}\") plt.legend() plt.grid(True) plt.show() ```","title":"G\u00f6rselle\u015ftirme"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Steps: - Generate \\(N\\) random \\((x, y)\\) points in \\([-1, 1] \\times [-1, 1]\\) . - Count how many satisfy \\(x^2 + y^2 \\leq 1\\) (inside the circle). - Estimate \\(\\pi\\) using the formula above.","title":"\ud83e\uddea 2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Plot all generated points. Highlight points inside the circle in one color (e.g., green). Points outside in another color (e.g., red). Optionally, draw the boundary of the unit circle.","title":"\ud83d\udcca 3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"Run simulations for increasing \\(N\\) (e.g., \\(100, 1000, 10^4, 10^5\\) ). Record the estimate of \\(\\pi\\) at each \\(N\\) . Plot \\(\\pi\\) estimates vs. \\(N\\) to observe convergence. Discuss computational time and accuracy.","title":"\ud83d\udcc8 4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"Part 2: Estimating \\(\\pi\\) Using Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon's Needle experiment involves dropping a needle of length \\(l\\) on a plane with parallel lines spaced \\(d\\) units apart. If \\(l \\leq d\\) , the probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2l}{\\pi d} \\] Rearranged to estimate \\(\\pi\\) : \\[ \\pi \\approx \\frac{2l \\cdot N}{d \\cdot C} \\] Where: - \\(N\\) = number of needle drops - \\(C\\) = number of crosses (intersections with a line) ```python import numpy as np import matplotlib.pyplot as plt def estimate_pi_buffon(num_needles): length = 1.0 # Needle length spacing = 1.0 # Line spacing crosses = 0 x_start = [] y_start = [] x_end = [] y_end = [] cross_flags = [] for _ in range(num_needles): y_center = np.random.uniform(0, spacing / 2) angle = np.random.uniform(0, np.pi / 2) y_proj = (length / 2) * np.sin(angle) if y_proj >= y_center: crosses += 1 cross_flags.append(True) else: cross_flags.append(False) x0 = 0 y0 = y_center x1 = (length / 2) * np.cos(angle) y1 = (length / 2) * np.sin(angle) x_start.append(x0 - x1) y_start.append(y0 - y1) x_end.append(x0 + x1) y_end.append(y0 + y1) if crosses == 0: pi_est = None print(\"No crosses occurred \u2014 try more drops.\") else: pi_est = (2 * num_needles) / crosses # Plotting plt.figure(figsize=(8, 4)) for i in range(num_needles): color = 'green' if cross_flags[i] else 'gray' plt.plot([x_start[i], x_end[i]], [y_start[i], y_end[i]], color=color, alpha=0.5) for y in np.arange(0, spacing * 2, spacing): plt.axhline(y=y, color='black', linewidth=0.5) plt.title(f\"Buffon\u2019s Needle Simulation\\nNeedles: {num_needles}, \u03c0 \u2248 {pi_est:.5f}\" if pi_est else \"No estimate\") plt.axis('equal') plt.grid(True) plt.show() ```","title":"\ud83d\udcd0 1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"Steps: - Set needle length \\(l\\) and line spacing \\(d\\) (commonly \\(l = d = 1\\) ). - Drop the needle \\(N\\) times: - Randomly place its center \\(y \\in [0, d/2]\\) - Randomly select angle \\(\\theta \\in [0, \\pi/2]\\) - If \\(y \\leq \\frac{l}{2} \\sin(\\theta)\\) , it's a hit (crossing). - Use above formula to estimate \\(\\pi\\) .","title":"\ud83e\uddea 2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Show parallel lines spaced \\(d\\) units apart. Draw needles as lines across drops. Use different colors for crossing vs non-crossing needles.","title":"\ud83d\udcca 3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Vary number of drops \\(N\\) : \\(100, 1000, 10000, \\ldots\\) Record number of crossings \\(C\\) and \\(\\pi\\) estimate. Compare with the circle-based method: Which one converges faster? Which one is more stable? Discuss runtime and sensitivity to randomness.","title":"\ud83d\udcc8 4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#definitions-and-key-concepts","text":"Monte Carlo Method : A computational algorithm relying on repeated random sampling to obtain numerical results. Unit Circle : Circle with radius \\(r = 1\\) centered at origin. Buffon's Needle : Classical probability problem estimating \\(\\pi\\) from geometric probabilities. Convergence Rate : How fast an estimate approaches the true value as the number of samples increases.","title":"\ud83e\uddfe Definitions and Key Concepts"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"","title":"\ud83d\udcc8 Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-markdown-document","text":"Includes all theory, explanations, and observations.","title":"1. Markdown Document:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-python-simulations","text":"One script for the unit circle method. One script for Buffon\u2019s Needle method.","title":"2. Python Simulations:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visual-outputs","text":"Scatter plots of circle simulation. Needle-drop visualizations. \\(\\pi\\) vs number of samples graphs.","title":"3. Visual Outputs:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-comparative-analysis","text":"Table of \\(\\pi\\) estimates vs sample size. Commentary on computational efficiency and accuracy.","title":"4. Comparative Analysis:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#references","text":"Grinstead, C. M., & Snell, J. L. (1997). Introduction to Probability . Wikipedia: Monte Carlo method Wikipedia: Buffon's needle","title":"\ud83d\udd17 References"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Measuring the Acceleration Due to Gravity with a Simple Pendulum Objective To determine the acceleration due to gravity, \\(g\\) , using a simple pendulum, and to analyze the uncertainties in the measurements. Apparatus String (length \\(\\approx 1.000\\) m) Small weight (metal washer, keychain) Stopwatch (precision: \\(0.01\\) s) Ruler or measuring tape (precision: \\(1\\) mm) Uncertainty in length: \\[ \\Delta L = \\frac{1 \\, \\text{mm}}{2} = 0.0005 \\, \\text{m} \\] Procedure Construct a simple pendulum of length \\(L = 1.000\\) m from the suspension point to the center of mass. Displace the pendulum by a small angle ( \\(<15^\\circ\\) ) and release it. Use a stopwatch to measure the time taken for 10 complete oscillations. Repeat the measurement 10 times and record the results. Compute the average time, standard deviation, and uncertainty. Determine the period \\(T\\) and calculate \\(g\\) using the standard formula. Observations Time for 10 Oscillations Trial Time (s) 1 15.59 2 15.53 3 15.60 4 15.69 5 15.52 6 15.52 7 15.70 8 15.62 9 15.49 10 15.58 Average time: \\[ \\overline{T_{10}} = 15.584 \\, \\text{s} \\] Standard deviation: \\[ \\sigma_T = 0.0674 \\, \\text{s} \\] Uncertainty in mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.0213 \\, \\text{s} \\] import matplotlib.pyplot as plt import numpy as np # \u00d6rnek veriler times = [15.59, 15.53, 15.60, 15.69, 15.52, 15.52, 15.70, 15.62, 15.49, 15.58] trials = list(range(1, len(times)+1)) # Ortalama ve standart sapma mean_time = np.mean(times) std_dev = np.std(times) # Grafik \u00e7izimi plt.figure(figsize=(10, 5)) plt.plot(trials, times, marker='o', color='royalblue', linewidth=2, label='Time for 10 oscillations') plt.axhline(mean_time, color='green', linestyle='--', linewidth=1.5, label=f'Mean = {mean_time:.2f}s') plt.fill_between(trials, mean_time - std_dev, mean_time + std_dev, color='lightblue', alpha=0.4, label='\u00b11 SD') # Etiketler ve ba\u015fl\u0131k plt.title(\"Measured Time for 10 Oscillations\") plt.xlabel(\"Trial\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() Calculations Time Period of One Oscillation \\[ T = \\frac{\\overline{T_{10}}}{10} = \\frac{15.584}{10} = 1.5584 \\, \\text{s} \\] \\[ \\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.0213}{10} = 0.00213 \\, \\text{s} \\] Acceleration Due to Gravity \\[ g = \\frac{4 \\pi^2 L}{T^2} = \\frac{4 \\cdot \\pi^2 \\cdot 1.000}{(1.5584)^2} = \\frac{39.4784}{2.4296} = 16.24 \\, \\text{m/s}^2 \\] Uncertainty in \\(g\\) \\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } = \\sqrt{ (0.0005)^2 + (2 \\cdot 0.00213 / 1.5584)^2 } = 0.0027 \\] \\[ \\Delta g = g \\cdot \\frac{\\Delta g}{g} = 16.24 \\cdot 0.0027 = 0.044 \\, \\text{m/s}^2 \\] Final Result \\[ g = 16.24 \\pm 0.044 \\, \\text{m/s}^2 \\] Discussion The calculated value of \\(g\\) is higher than the standard value \\(9.81 \\, \\text{m/s}^2\\) . Potential reasons: Human reaction delay using a stopwatch Miscounting of oscillations Slight deviation from small angle assumption Major uncertainty source: \\(\\Delta T\\) Accuracy can be improved by: Increasing pendulum length Timing more oscillations (e.g., 20) Using electronic timing methods Conclusion The experiment illustrates how \\(g\\) can be determined using a simple pendulum and basic equipment. Proper technique and uncertainty analysis are essential for obtaining reliable and accurate results.","title":"Measuring the Acceleration Due to Gravity with a Simple Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-the-acceleration-due-to-gravity-with-a-simple-pendulum","text":"","title":"Measuring the Acceleration Due to Gravity with a Simple Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#objective","text":"To determine the acceleration due to gravity, \\(g\\) , using a simple pendulum, and to analyze the uncertainties in the measurements.","title":"Objective"},{"location":"1%20Physics/7%20Measurements/Problem_1/#apparatus","text":"String (length \\(\\approx 1.000\\) m) Small weight (metal washer, keychain) Stopwatch (precision: \\(0.01\\) s) Ruler or measuring tape (precision: \\(1\\) mm) Uncertainty in length: \\[ \\Delta L = \\frac{1 \\, \\text{mm}}{2} = 0.0005 \\, \\text{m} \\]","title":"Apparatus"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"Construct a simple pendulum of length \\(L = 1.000\\) m from the suspension point to the center of mass. Displace the pendulum by a small angle ( \\(<15^\\circ\\) ) and release it. Use a stopwatch to measure the time taken for 10 complete oscillations. Repeat the measurement 10 times and record the results. Compute the average time, standard deviation, and uncertainty. Determine the period \\(T\\) and calculate \\(g\\) using the standard formula.","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#observations","text":"","title":"Observations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#time-for-10-oscillations","text":"Trial Time (s) 1 15.59 2 15.53 3 15.60 4 15.69 5 15.52 6 15.52 7 15.70 8 15.62 9 15.49 10 15.58 Average time: \\[ \\overline{T_{10}} = 15.584 \\, \\text{s} \\] Standard deviation: \\[ \\sigma_T = 0.0674 \\, \\text{s} \\] Uncertainty in mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{10}} = 0.0213 \\, \\text{s} \\] import matplotlib.pyplot as plt import numpy as np # \u00d6rnek veriler times = [15.59, 15.53, 15.60, 15.69, 15.52, 15.52, 15.70, 15.62, 15.49, 15.58] trials = list(range(1, len(times)+1)) # Ortalama ve standart sapma mean_time = np.mean(times) std_dev = np.std(times) # Grafik \u00e7izimi plt.figure(figsize=(10, 5)) plt.plot(trials, times, marker='o', color='royalblue', linewidth=2, label='Time for 10 oscillations') plt.axhline(mean_time, color='green', linestyle='--', linewidth=1.5, label=f'Mean = {mean_time:.2f}s') plt.fill_between(trials, mean_time - std_dev, mean_time + std_dev, color='lightblue', alpha=0.4, label='\u00b11 SD') # Etiketler ve ba\u015fl\u0131k plt.title(\"Measured Time for 10 Oscillations\") plt.xlabel(\"Trial\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Time for 10 Oscillations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#time-period-of-one-oscillation","text":"\\[ T = \\frac{\\overline{T_{10}}}{10} = \\frac{15.584}{10} = 1.5584 \\, \\text{s} \\] \\[ \\Delta T = \\frac{\\Delta T_{10}}{10} = \\frac{0.0213}{10} = 0.00213 \\, \\text{s} \\]","title":"Time Period of One Oscillation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#acceleration-due-to-gravity","text":"\\[ g = \\frac{4 \\pi^2 L}{T^2} = \\frac{4 \\cdot \\pi^2 \\cdot 1.000}{(1.5584)^2} = \\frac{39.4784}{2.4296} = 16.24 \\, \\text{m/s}^2 \\]","title":"Acceleration Due to Gravity"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"\\[ \\frac{\\Delta g}{g} = \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } = \\sqrt{ (0.0005)^2 + (2 \\cdot 0.00213 / 1.5584)^2 } = 0.0027 \\] \\[ \\Delta g = g \\cdot \\frac{\\Delta g}{g} = 16.24 \\cdot 0.0027 = 0.044 \\, \\text{m/s}^2 \\]","title":"Uncertainty in \\(g\\)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#final-result","text":"\\[ g = 16.24 \\pm 0.044 \\, \\text{m/s}^2 \\]","title":"Final Result"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"The calculated value of \\(g\\) is higher than the standard value \\(9.81 \\, \\text{m/s}^2\\) . Potential reasons: Human reaction delay using a stopwatch Miscounting of oscillations Slight deviation from small angle assumption Major uncertainty source: \\(\\Delta T\\) Accuracy can be improved by: Increasing pendulum length Timing more oscillations (e.g., 20) Using electronic timing methods","title":"Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"The experiment illustrates how \\(g\\) can be determined using a simple pendulum and basic equipment. Proper technique and uncertainty analysis are essential for obtaining reliable and accurate results.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}